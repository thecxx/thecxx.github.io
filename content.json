{"meta":{"title":"KAMI","subtitle":"士不可以不弘毅，任重而道远。","description":"士不可以不弘毅，任重而道远。","author":"Kami","url":"https://oldchan.net"},"pages":[{"title":"categories","date":"2016-04-29T09:07:56.000Z","updated":"2022-06-02T12:47:44.825Z","comments":false,"path":"categories/index.html","permalink":"https://oldchan.net/categories/index.html","excerpt":"","text":""},{"title":"history","date":"2018-09-09T15:34:08.000Z","updated":"2022-06-02T12:47:44.826Z","comments":true,"path":"history/index.html","permalink":"https://oldchan.net/history/index.html","excerpt":"","text":""},{"title":"访客留言","date":"2018-09-09T15:34:08.000Z","updated":"2022-06-02T12:47:44.826Z","comments":true,"path":"guestbook/index.html","permalink":"https://oldchan.net/guestbook/index.html","excerpt":"","text":""},{"title":"一个兴趣使然的技术人员","date":"2016-04-29T09:12:41.000Z","updated":"2022-06-02T12:47:44.824Z","comments":false,"path":"about/index.html","permalink":"https://oldchan.net/about/index.html","excerpt":"","text":"MeName: KamiSocial: Github 技能: c/c++、go、php、bash、python、javascript… 等等经历: 熊猫直播 奇虎360"},{"title":"","date":"2022-07-08T12:46:55.291Z","updated":"2022-07-08T12:46:55.291Z","comments":true,"path":"s1/README.html","permalink":"https://oldchan.net/s1/README.html","excerpt":"","text":"s1 Static files hosting."},{"title":"tags","date":"2016-04-29T09:10:18.000Z","updated":"2022-06-02T12:47:44.827Z","comments":false,"path":"tags/index.html","permalink":"https://oldchan.net/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Golang深度解读：调度","slug":"notes/golang/advanced/schedule","date":"2022-12-10T05:27:16.000Z","updated":"2023-01-13T08:31:03.675Z","comments":true,"path":"2022/12/10/notes/golang/advanced/schedule/","link":"","permalink":"https://oldchan.net/2022/12/10/notes/golang/advanced/schedule/","excerpt":"通过对M，P，G的简单介绍，我们大致上了解了这几种概念在Go语言运行机制中的基本作用 M封装操作系统的线程，提供运行资源 P封装G运行过程中需要的辅助资源，并为G提供排队管理 G封装运行上下文，提供运行用户代码的能力 三者协作，只要有源源不断可运行的G存在，M+P的组合就会不断地循环调度，直到没有可运行的G时，M与P解绑，并进入休眠状态。","text":"通过对M，P，G的简单介绍，我们大致上了解了这几种概念在Go语言运行机制中的基本作用 M封装操作系统的线程，提供运行资源 P封装G运行过程中需要的辅助资源，并为G提供排队管理 G封装运行上下文，提供运行用户代码的能力 三者协作，只要有源源不断可运行的G存在，M+P的组合就会不断地循环调度，直到没有可运行的G时，M与P解绑，并进入休眠状态。 调度模型调度流程每一个Worker M在工作时，都会进入到如下的调度流程中 以runtime.schedule()函数为核心的调度逻辑，通过runtime.findRunnable()函数查找可运行的G，再进入到一套标准的用户代码执行逻辑中，直到让出执行权(图以执行runtime.Gosched()函数让出执行权举例)。如果调度流程在执行runtime.findRunnable()函数过程中，没有查找到可运行的G，则调用runtime.stopm()函数，将当前M挂起，进入到休眠状态，直到再次被唤醒时，返回到runtime.findRunnable()函数中继续查找可运行的G，并再次回到调度流程。 简化模型对调度流程的进一步简化，可将调度的状态切换理解成如下模型： 当有可运行的G存在时，调度模型始终在find与exec之间循环切换，直到无可运行G时，进入sleep状态，直到被唤醒。 进入调度无论是进程启动执行(主线程执行)，还是执行过程中创建新的Worker M，执行流程最终都会进入到runtime.mstart()函数中，并按循序执行runtime.mstart() -&gt; runtime.mstart0() -&gt; runtime.mstart1()，最终进入到调度流程中。 查找可运行G每一个可运行的G都是一个待执行的任务。函数runtime.schedule()作为调度流程的核心，主要负责执行查找任务和执行任务，其中查找任务的逻辑由runtime.findRunnable()函数来负责完成。忽略与查找可运行G目标不相关的逻辑，可以将查找流程总结为如下几个步骤： 第一次从全局队列中查找可运行G(每执行61次G，则从全局队列中获取一次) 从本地队列中查找可运行G 第二次从全局队列中查找可运行G 从netpoll中查找可运行G 从其他P中窃取可运行G 以上几个步骤都执行完，依然没有查找到可运行的G时，则会进入无事可做的状态，代码里也是这么注释的！1// We have nothing to do. 在这种状态下，当前执行的Worker M会与P解绑，并进入休眠状态，但再此之前，还会进行一些其他工作，如：GC扫描。在查找可运行G的流程中，简单说下1和4两个步骤。 周期性从全局队列中获取G：根据注释与代码逻辑，这么做的主要目的是为了保证调度的公平性，假如本地队列一直有可运行的G存在，全局队列的G就会长期得不到运行机会。netpoll的G：当代码中存在网络访问时，负责连接读写的Goroutine就绪时，会被调度，这里后续章节再进一步分析。 最后的最后，调度流程就会将P解绑，并通过调用runtime.stopm()函数将M挂起，进入休眠状态。 全局查找从全局队列中查找可运行的G，使用的是runtime.globrunqget()函数，因为是操作全局队列，所以调用该函数前，需要对sched.lock全局变量字段加锁。该函数主要用于从全局队列中获取可运行G，根据实际情况，假如获取的数量是1，则直接返回获取到的G；假如获取的数量大于1，则返回其中一个G，并将其他获取到的G保存到本地队列。 函数原型：1func globrunqget(_p_ *p, max int32) *g max参数用来限制从全局队列获取可运行G的数量。 备注：第一次和第二次从全局队列中查找可运行的G最大的区别在于，第一次获取时max参数设置的是1，第二次设置的是0，所以第一次最多只会从全局队列中获取1个可运行G，并不会从全局队列中转移可运行的G到本地队列 接下来，再看看这个函数的具体处理步骤：第一步：使用全局队列的长度 / P的最大数量 = 得到每一个P的平均负载值n 这一步主要计算一个公平的，每一个P除了本地队列中的G之外，全局队列中自己还有多少G需要处理。 第二步：计算出负载值n后，再计算本地队列的最大长度除以2，用来限制n的最大值123if n &gt; int32(len(_p_.runq))/2 &#123; n = int32(len(_p_.runq)) / 2&#125; P中runq字段的结构定义如下，因此n的最大长度为128。1234567891011type p struct &#123; ... // Queue of runnable goroutines. Accessed without lock. runqhead uint32 runqtail uint32 runq [256]guintptr ...&#125; 第三步：获取一个可运行的G作为返回值，并将n-1个可运行的G保存至本地队列P中 窃取工作当调度流程从哪里都找不到可运行的G时，作为专业打工人，会自觉地尝试从其他的P那找点可运行的G过来。窃取可运行G的主要工作由runtime.stealWork()函数来负责，但这个函数的主要逻辑是在选择目标P，并在确认目标后，交给runtime.runqsteal()函数来完成实际的可运行G的转移。 选择目标P先来看看runtime.stealWork()函数是怎么选择目标P的吧。 先是选择策略，这里采用的是随机起始位置，非连续性遍历所有P的方案，非连续性即为遍历完下标i之后，下一个遍历的下标并不是i+1，而是伪随机的其他位置，直到所有的P都遍历一次 再是重试机制，在选择策略之外包含一层循环逻辑，循环次数为固定值4，即重试4次 窃取半数G当确定了目标P之后，就会调用runtime.runqsteal()函数来进行实际的转移操作，该函数的内部还会调用另一个runtime.runqgrab()函数来实现半数转移，即将目标P一半的可运行G转移给当前P。 执行可运行G现在调度流程中已经存在一个可运行的G了，接下来就需要调用runtime.execute()函数来执行它。这段过程主要对G做一些字段更新，比如：将状态由_Grunnable切换成_Grunning，将G与M绑定等等，最后交给runtime.gogo()函数处理。 让渡执行权当运行中的G因为各种原因，交出运行资源后，调度流程便会再次回到runtime.schedule()函数进入下一轮循环。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://oldchan.net/categories/笔记/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://oldchan.net/tags/golang/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://oldchan.net/categories/笔记/"}]},{"title":"Golang深度解读：P","slug":"notes/golang/advanced/p","date":"2022-08-15T02:20:24.000Z","updated":"2023-01-13T09:45:31.023Z","comments":true,"path":"2022/08/15/notes/golang/advanced/p/","link":"","permalink":"https://oldchan.net/2022/08/15/notes/golang/advanced/p/","excerpt":"通常，在各种技术文章中，P都是被定义成Processor，处理器？那么，Go定义的处理器与操作系统的处理器可以等价理解吗？两者具有相似的概念，但实现原理不同，系统线程基于CPU(操作系统的处理器)运行，Go定义的M基于系统线程创建，P(Processor)基于M运行。 当执行编写的Go代码时，Go会将运行上下文封装成G，等待运行的G会在P中排队，协程调度时，从P中获取到可运行的G，g0再将执行权让渡给G，然后进入用户代码逻辑。","text":"通常，在各种技术文章中，P都是被定义成Processor，处理器？那么，Go定义的处理器与操作系统的处理器可以等价理解吗？两者具有相似的概念，但实现原理不同，系统线程基于CPU(操作系统的处理器)运行，Go定义的M基于系统线程创建，P(Processor)基于M运行。 当执行编写的Go代码时，Go会将运行上下文封装成G，等待运行的G会在P中排队，协程调度时，从P中获取到可运行的G，g0再将执行权让渡给G，然后进入用户代码逻辑。 P与G可运行G通过队列的方式保存于P中，P维护一份最大长度为256的本地队列，已退出的G也会保存到P中，待创建新的G时再次使用。 G的创建G的创建采用go关键字实现。 123go func() &#123; // 代码逻辑&#125;() 在编译过程中会将go关键字的操作，转换成调用runtime.newproc()函数的逻辑，然后通过runtime.newproc1()函数创建并初始化g结构，再回到runtime.newproc()函数，通过调用runtime.runqput()函数将新创建的G保存至本地队列中。 1234567891011121314151617// Create a new g running fn.// Put it on the queue of g's waiting to run.// The compiler turns a go statement into a call to this.func newproc(fn *funcval) &#123; gp := getg() pc := getcallerpc() systemstack(func() &#123; newg := newproc1(fn, gp, pc) _p_ := getg().m.p.ptr() runqput(_p_, newg, true) if mainStarted &#123; wakep() &#125; &#125;)&#125; 备注：采用go关键字创建的G，会直接保存在本地队列中，并设置成下一个G，等待调度 P与MP提供了各种运行G所需要的辅助资源，为可运行G提供了队列服务，但只有P又无法处理这些可运行的G，所以P还需要与M进行绑定，形成M+P的组合，由M提供运行资源，这样才能保证可运行G的顺利执行。 与P形成绑定关系的M都是Worker M，要启动一个Worker M，通常需要先找到一个可用的P(空闲的P或非空闲的P绑定到新的M)，将P与M进行绑定，之后M才能进入调度状态。调度过程中，可以通过runtime.startm()函数启动M，当存在空闲中的M时(休眠状态)，则唤醒休眠中的M，如果没有空闲的M，则需要创建新的M m0/g0/p0Go内核中有两个特殊的变量m0与g0，定义在src/runtime/proc.go文件中，进程在启动后，主线程会从程序的入口开始执行，这是进程中的第一个线程，而基于第一个线程创建的M就是m0，因此在Go内核初始化过程中，会将第一个线程的运行环境保存到m0中，而相对的创建M时需要分配g0的操作，在m0这里，直接使用的全局变量g0。 在一系列的初始化过程中，会执行到runtime.schedinit()函数，而函数内部又会初始化一次P的数量，主要通过runtime.procresize()函数来实现，该函数内，又会判断当前M是否绑定P，如果没有绑定，则将allp[0]中的P与M进行绑定，其中全局变量allp保存着所有P的指针地址。 P的数量P的数量一般都会设置成与CPU核数相等，Go内核在启动时会自动初始化。在runtime.osinit()函数中获取当前操作系统的CPU核数，并在runtime.schedinit()函数中进行P初始化设置，同时在设置之前，会尝试读取环境变量GOMAXPROCS来覆盖CPU核数。 121. runtime.osinit() -&gt; 获取CPU核数2. runtime.schedinit() 除此之外，还可以在开发过程中，通过runtime.GOMAXPROCS()函数对P的数量进行设置。 P的职责通过P结构体的定义与Go内核调度逻辑可见，P的核心工作是在调度中维护G与M的使用关系，一般情况下，G只有在P中排队，才能合理的使用到M的运行资源。P负责维护一份可运行G的队列，另外还会维护一份已退出G的队列(状态为Gdead的协程)，除此之外，还会维护G在运行过程中需要分配的内存，defer结构等等，不同的细节在后续章节中再深入分析。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://oldchan.net/categories/笔记/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://oldchan.net/tags/golang/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://oldchan.net/categories/笔记/"}]},{"title":"Golang深度解读：M","slug":"notes/golang/advanced/m","date":"2022-07-24T05:20:24.000Z","updated":"2022-07-25T05:25:14.813Z","comments":true,"path":"2022/07/24/notes/golang/advanced/m/","link":"","permalink":"https://oldchan.net/2022/07/24/notes/golang/advanced/m/","excerpt":"Go语言将线程抽象成M(Machine)，每个M都是可以独立运行的单元，M的数据结构中主要包含的是跟系统环境相关的字段。 Go语言将可执行的上下文保存在G(Goroutine)中，G的数据结构中主要包含跟执行环境相关的字段，包括寄存器值，栈地址、defer，panic的指针等等。 在《Golang深度解读：g0》中，简单讲述了g0的基本信息和在调度中所负责的工作。最先了解g0，主要原因是g0才是真正意义上在线程上运行的逻辑，M在创建之后，系统环境相关的数据保存在M中，线程的执行数据保存在g0中，g0与普通用户协程共用相同的数据结构和计算逻辑，只是在内核调度过程中，需要区分g0与用户协程的部分边界。","text":"Go语言将线程抽象成M(Machine)，每个M都是可以独立运行的单元，M的数据结构中主要包含的是跟系统环境相关的字段。 Go语言将可执行的上下文保存在G(Goroutine)中，G的数据结构中主要包含跟执行环境相关的字段，包括寄存器值，栈地址、defer，panic的指针等等。 在《Golang深度解读：g0》中，简单讲述了g0的基本信息和在调度中所负责的工作。最先了解g0，主要原因是g0才是真正意义上在线程上运行的逻辑，M在创建之后，系统环境相关的数据保存在M中，线程的执行数据保存在g0中，g0与普通用户协程共用相同的数据结构和计算逻辑，只是在内核调度过程中，需要区分g0与用户协程的部分边界。 worker mGo语言程序在执行过程中会创建多个M，但并不跟P的数量完全匹配，跟P绑定使用的M一般视为Worker Thread(为了统一概念，后面统一称Worker M)，即用户计算逻辑能使用到的线程，P数量的设置也直接影响用户协程的并行执行能力，关于P数量的设置可参考runtime.GOMAXPROCS()。 Worker M的启动通常由runtime.wakep()开始，在执行runtime.startm()时，需要获取空闲状态的P和空闲状态的M，如果没有空闲状态的P，则不会继续创建流程，而如果没有空闲状态的M，则会执行runtime.newm()创建新的M。 M结构的内存分配与g0的初始化就在runtime.newm()中进行，函数runtime.newosproc()是Go抽象出来的统一接口，主要用来创建系统线程，通过条件编译的方式，在不同的平台上有不同的实现方式，如：darwin上底层执行的是pthread_create系统接口创建线程，而在windows上执行的是CreateThread系统接口，创建线程的同时，会将已经初始化完成的M结构的指针传递到对应的创建线程的系统接口中，由线程的启动回调负责在新线程中做后续的处理，直到流程执行至runtime.mstart()，新M的执行流程参考《Golang深度解读：g0》。 m0Worker M通常是由其他M通过结构初始化并访问系统调用，执行线程创建接口创建出来，最后经过runtime.mstart()进入正常Worker M的计算逻辑，那第一个M是怎么来的呢？ 在Go语言runtime包中，通过不同版本的汇编实现了不同平台上程序启动的main()函数入口，然后执行runtime.rt0_go()完成对Go程序的初始化，并使用全局定义的m0/g0初始化第一个M，并将runtime.main()函数地址传入runtime.newproc()创建第一个用户协程，再执行runtime.mstart()进行正常后续流程。 接下来的流程就比较熟悉了，m0进入调度循环，并启动第一个用户协程runtime.main()进行前期的初始化，再访问用户代码中的main.main()正式执行用户代码逻辑。 注：m0也是正常的Worker M，只不过创建的流程不太一样 sysmonGo语言中除了负责执行用户协程的的一组Worker M之外，还有一个独立的监控M，称之为sysmon。 123systemstack(func() &#123; newm(sysmon, nil, -1)&#125;) sysmon在m0初始化完，执行第一个协程runtime.main()时，在runtime.main()函数中被创建，因为sysmon不直接服务于用户协程，因此没有绑定可执行的P，没有绑定P的M，所有的执行流程都在g0中。sysmon主要负责完成Go程序在执行期间的一些协同工作，如：处理系统调用阻塞(syscall)、用户协程执行时间过长(关于Go程序的抢占调度方案后面再细致的剖析)，还有超时未poll network等等问题。 template thread在runtime.newm()的函数中，创建新的线程时，由于Linux之类的系统底层是通过类似fork的系统调用创建线程，当M处于locked状态或M是在CGO中创建，在fork时可能会复制很多不可预知的状态，于是使用到了template thread的处理机制，在不方便由当前M直接创建新M时，将创建任务传递到template thread中，让template thread负责创建新的M，并按正常流程启动。 template thread由runtime.startTemplateThread()创建，在m0初始化完，执行runtime.main()时，在CGO的检查项中执行runtime.startTemplateThread()创建template thread，另一处是runtime.LockOSThread()中，并且template thread也是不绑定P的。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://oldchan.net/categories/笔记/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://oldchan.net/tags/golang/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://oldchan.net/categories/笔记/"}]},{"title":"Golang深度解读：g0","slug":"notes/golang/advanced/g0","date":"2022-07-10T12:56:40.000Z","updated":"2022-07-21T12:31:36.386Z","comments":true,"path":"2022/07/10/notes/golang/advanced/g0/","link":"","permalink":"https://oldchan.net/2022/07/10/notes/golang/advanced/g0/","excerpt":"g0是Go语言中一种特殊协程，每个M都拥有一个g0协程，主要负责当前M上用户协程的调度工作，在执行runtime.newm()函数创建M时，会同时初始化g0协程。","text":"g0是Go语言中一种特殊协程，每个M都拥有一个g0协程，主要负责当前M上用户协程的调度工作，在执行runtime.newm()函数创建M时，会同时初始化g0协程。 g0协程执行时使用系统栈，每个线程从启动开始往下执行，都属于g0的工作范围，直到运行至runtime.gogo()启动用户协程，g0的工作才算暂时告一段落。 如图所示，Go语言中的协程调度总是不断地经历着类似的循环，以runtime.Gosched()让出调度的流程举例。 当M创建之后，会同时初始化g0，运行在不同的平台上时，程序兼容各平台特性，最终执行到runtime.mstart()正式启动g0的调度逻辑，再经过runtime.mstart1()进入到调度循环中，由runtime.gogo()启动用户协程，在用户逻辑中执行runtime.Gosched()让出执行权限，再经过runtime.mcall()回到g0的工作范围(这条流程下，刚刚执行过的协程会被放到全局队列中)。 反复重用的栈帧调度技术上，有不少细节的设计很有技巧，其中一个就是对于g0栈帧的管理。 g0采用的是无限递归的方式重复运行调度逻辑，正常的程序执行路径都是保存在栈内，按正常程序的编译结果，g0的协程栈会无限膨胀直到移除，因此Go语言对这里进行了一些优化，当执行到runtime.mstart1()时，g0会提前计算出一份协程栈的地址数据，保存在g0的结构中。12_g_.sched.pc = getcallerpc()_g_.sched.sp = getcallersp() 当g0执行到runtime.gogo()切换至用户协程时，并不会将当前g0的栈帧保存起来，而当用户协程经过runtime.mcall()回到g0时，再次加载的还是最初在runtime.mstart1()中计算出来的栈地址数据，通过这种技巧，反复将栈顶指针重置，从而实现栈帧的重复使用。 12345678910111213141516171819202122232425262728TEXT runtime·mcall&lt;ABIInternal&gt;(SB), NOSPLIT, $0-8 MOVQ AX, DX // DX = fn // save state in g-&gt;sched MOVQ 0(SP), BX // caller's PC MOVQ BX, (g_sched+gobuf_pc)(R14) LEAQ fn+0(FP), BX // caller's SP MOVQ BX, (g_sched+gobuf_sp)(R14) MOVQ BP, (g_sched+gobuf_bp)(R14) // switch to m-&gt;g0 &amp; its stack, call fn MOVQ g_m(R14), BX MOVQ m_g0(BX), SI // SI = g.m.g0 CMPQ SI, R14 // if g == m-&gt;g0 call badmcall JNE goodm JMP runtime·badmcall(SB)goodm: MOVQ R14, AX // AX (and arg 0) = g MOVQ SI, R14 // g = g.m.g0 get_tls(CX) // Set G in TLS MOVQ R14, g(CX) MOVQ (g_sched+gobuf_sp)(R14), SP // sp = g0.sched.sp PUSHQ AX // open up space for fn's arg spill slot MOVQ 0(DX), R12 CALL R12 // fn(g) POPQ AX JMP runtime·badmcall2(SB) RET 优先提高并行度Worker角色的M被创建时，默认都需要再创建另一个新的M，直至没有空闲的p为止。 这块的处理流程是每创建一个M，在执行调度时，如果当前M中spinning成员被标记为true，则尝试创建另一个M，采用全局变量sched.nmspinning控制创建流程，实现M的顺序创建。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://oldchan.net/categories/笔记/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://oldchan.net/tags/golang/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://oldchan.net/categories/笔记/"}]},{"title":"Golang深度解读","slug":"notes/golang/advanced/list","date":"2022-07-10T12:50:40.000Z","updated":"2023-01-13T10:01:42.218Z","comments":true,"path":"2022/07/10/notes/golang/advanced/list/","link":"","permalink":"https://oldchan.net/2022/07/10/notes/golang/advanced/list/","excerpt":"内核实现 《Golang深度解读：g0》 《Golang深度解读：M》 《Golang深度解读：P》","text":"内核实现 《Golang深度解读：g0》 《Golang深度解读：M》 《Golang深度解读：P》 《Golang深度解读：调度》 语法特性函数 《Golang深度解读：func》 网络通信 《Golang深度解读：Context》","categories":[{"name":"笔记","slug":"笔记","permalink":"https://oldchan.net/categories/笔记/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://oldchan.net/tags/golang/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://oldchan.net/categories/笔记/"}]},{"title":"6年前，决定不再继续精进PHP","slug":"opinion/give_up_the_php","date":"2022-06-15T13:54:24.000Z","updated":"2022-07-13T05:12:14.009Z","comments":true,"path":"2022/06/15/opinion/give_up_the_php/","link":"","permalink":"https://oldchan.net/2022/06/15/opinion/give_up_the_php/","excerpt":"「选择某种技术作为谋生手段，需要观察市场的需求变化」 PHP经历了最高光的辉煌阶段，从1995年正式发布开始，经过二十多年的快速发展，才逐渐达到发展瓶颈。PHP最鲜亮的标志就是语言入门简单，功能迭代快速，配合健全的WEB套件组合(LAMP、LNMP)，开箱即用，它的特性很符合互联网行业快速发展的开发需要。 技能连接着企业与劳动者，用户处于需求链路的最前端，用户的需求决定了产品的形态，产品的形态决定了企业方向和经营方式，也同时决定了依赖资源的结构(包括对技术类资源的需求)。","text":"「选择某种技术作为谋生手段，需要观察市场的需求变化」 PHP经历了最高光的辉煌阶段，从1995年正式发布开始，经过二十多年的快速发展，才逐渐达到发展瓶颈。PHP最鲜亮的标志就是语言入门简单，功能迭代快速，配合健全的WEB套件组合(LAMP、LNMP)，开箱即用，它的特性很符合互联网行业快速发展的开发需要。 技能连接着企业与劳动者，用户处于需求链路的最前端，用户的需求决定了产品的形态，产品的形态决定了企业方向和经营方式，也同时决定了依赖资源的结构(包括对技术类资源的需求)。 互联网快速发展期间，由于投资家对行业的认可，资金的投入都比较宽裕，这种信心也是来自于用户体量的发展、市场规模的不断壮大。用户越来越多，需求旺盛，外部资金很充足的情况下，只要迭代速度够快就能赚钱。 随着互联网用户群体逐渐趋于饱和，基本的产品需求也开始饱和时，如果没有出现创新型变革，产品的迭代就会开始平缓，对于企业而言，一般会有三种选择： 一是继续投入升级产品，提高收入 二是寻找新的用户群体，扩大收入 三是重构成本结构，优化技术，降低成本 PHP就像是为这座名为“互联网”的初创城市添砖加瓦的劳动者，它动作轻快，建设效率很高，很快就能建成许多三层六层的小楼，并且很快吸引许多人入住。 PHP步入瓶颈，并非技术问题。更多的是技术特性不符合当前的市场需求，如同Python，因为人工智能算法的兴起，重新回归热度一样，因为市场需要这种技术。 几年前，感觉到行业这些变化，一边是不少人说工作不好找，另一边是培训机构疯狂地吸引更多的人进入这个行业，加上那几年成功的产品出现周期越来越长，于是就计划着寻找新的方向。 当时团队有转Java的途径，但最后还是选择了Go，随后的几年里，Go相关的技术栈发生了井喷似的发展，容器化技术，弹性调度，微服务技术等等。","categories":[{"name":"长话","slug":"长话","permalink":"https://oldchan.net/categories/长话/"}],"tags":[{"name":"思考","slug":"思考","permalink":"https://oldchan.net/tags/思考/"}],"keywords":[{"name":"长话","slug":"长话","permalink":"https://oldchan.net/categories/长话/"}]},{"title":"好的产品?","slug":"opinion/good_product","date":"2022-05-05T08:00:38.000Z","updated":"2022-07-13T05:12:29.813Z","comments":true,"path":"2022/05/05/opinion/good_product/","link":"","permalink":"https://oldchan.net/2022/05/05/opinion/good_product/","excerpt":"“功能强大” 追求功能强大，似乎是一种魔咒，存在于专业人士的思维里，理所应当的，功能强大的产品能完成更多的可预料到的功能。 这种产品的价值，懂的人自然会懂，不懂的人却很难愿意为“多余”的功能支付成本。当缺少替代方案时，或许愿意追加成本，但假如出现了另一款类似功能的产品，并且功能简单到能满足用户需求，相对的，由于功能简单，研发投入的成本也会相应的低一些，需要用户支付的成本也会低一些，这个时候，用户又会怎么选择呢？ 为什么总会做出一款功能强大到超出很多用户需求的产品呢？想想主要原因应该有以下几点 产品功能足够丰富、强大，可以覆盖到更多的用户群体 更多专业的功能，能解决很多难度较高的问题 高端产品售价更高，利润更可观 基于以上的类似原因，开发者一般会孜孜不倦地在各种专业、多余的功能上投入巨大的精力和成本，那么对于开发者而言，投入的成本又怎么收回呢？","text":"“功能强大” 追求功能强大，似乎是一种魔咒，存在于专业人士的思维里，理所应当的，功能强大的产品能完成更多的可预料到的功能。 这种产品的价值，懂的人自然会懂，不懂的人却很难愿意为“多余”的功能支付成本。当缺少替代方案时，或许愿意追加成本，但假如出现了另一款类似功能的产品，并且功能简单到能满足用户需求，相对的，由于功能简单，研发投入的成本也会相应的低一些，需要用户支付的成本也会低一些，这个时候，用户又会怎么选择呢？ 为什么总会做出一款功能强大到超出很多用户需求的产品呢？想想主要原因应该有以下几点 产品功能足够丰富、强大，可以覆盖到更多的用户群体 更多专业的功能，能解决很多难度较高的问题 高端产品售价更高，利润更可观 基于以上的类似原因，开发者一般会孜孜不倦地在各种专业、多余的功能上投入巨大的精力和成本，那么对于开发者而言，投入的成本又怎么收回呢？ “概念较多、操作复杂、不够便捷” 接手过一个项目，这个项目的业务层面上定义了很多很专业的概念，任何非专业的人在使用时都会提出大量的疑问，主要是询问类似：“***是什么意思？”之类的问题，项目也有一些对外的使用手册，但使用手册上仍然引用的是很多专业的名词。 经过如此反复的客户来咨询类似的问题，加上自己也在梳理项目时，发现确实有很多的复杂性概念需要项目的维护人员给出解释。于是与之前的项目负责人进行了一些沟通，得到了一句看似很合理却又不是很自然的一句话：“啊？这么简单，文档都写了，他们还看不懂？” “知识的诅咒”，又称“专家盲点”，是一种认知偏差，指人在与他人交流的时候，下意识地假设对方拥有理解所需要的背景知识。在认知传授时，尽可能让自己意识到，对方可能什么都不懂。同样在设计产品时，也需有明确的目标用户定位，给予不同的上手引导，如：新手、使用过类似产品、骨灰级用户等等。 随着行业的逐步发展，当用户的使用习惯，操作心智也得到了培养之后，产品的引导就会更加容易一些，最开始的Android APP没有很统一的界面交互方案，也是慢慢地才统一到手机屏幕的下方，从此就成为了比较标准的交互布局。 总之而言，用户在实际使用产品之前，都应该尽可能地精简步骤，保证产品能尽快呈现到用户的面前，在用户心智中，实际使用产品之前的每个额外环节，可能每一个环节都会给产品减一次分。 “用户成本” 用户在使用一款产品时，总是期望获得一些东西，如：帮助类功能(主要是通过节省时间，精力，钱等完成某些事)、娱乐方式、比较好奇的内容、欢乐的心情、重要信息等等。 用户获取这些产品带来的效果的过程中，总是要付出一些时间，精力，钱财或者其他，这些都是用户的成本，而且投入越多，产品在用户心智中的价值需要大于或等于用户付出的成本，否则用户是不会那么乐意买单的。 用户对于产品的成本支出止于需求得到满足，更多的功能带来的多余成本支出，并非所有用户都愿意支付这部分溢价。","categories":[{"name":"长话","slug":"长话","permalink":"https://oldchan.net/categories/长话/"}],"tags":[],"keywords":[{"name":"长话","slug":"长话","permalink":"https://oldchan.net/categories/长话/"}]},{"title":"互联网络与元宇宙","slug":"opinion/internet_and_metaverse","date":"2021-11-17T04:44:09.000Z","updated":"2022-07-13T05:12:42.609Z","comments":true,"path":"2021/11/17/opinion/internet_and_metaverse/","link":"","permalink":"https://oldchan.net/2021/11/17/opinion/internet_and_metaverse/","excerpt":"上世纪60年代诞生的ARPANET，最初的目标是为了降低在战争时期，中心化控制机制带来的高风险问题，采用单点互联构建分布式去中心化网络可以大大降低系统风险。 之后，基于ARPANET的成果又诞生了互联网，用于解决ARPANET无法解决的“无法做到和个别计算机网络交流”问题。 再经过几十年的发展，又陆续诞生了许多基于TCP/IP协议产生的各种网络应用。 TCP/IP作为标准通信协议，基于TCP/IP协议互联的设备组成的网络即可称之为互联网。近几十年，发展最快的互联网应用莫过于Web网络，让信息分享越来越简单。","text":"上世纪60年代诞生的ARPANET，最初的目标是为了降低在战争时期，中心化控制机制带来的高风险问题，采用单点互联构建分布式去中心化网络可以大大降低系统风险。 之后，基于ARPANET的成果又诞生了互联网，用于解决ARPANET无法解决的“无法做到和个别计算机网络交流”问题。 再经过几十年的发展，又陆续诞生了许多基于TCP/IP协议产生的各种网络应用。 TCP/IP作为标准通信协议，基于TCP/IP协议互联的设备组成的网络即可称之为互联网。近几十年，发展最快的互联网应用莫过于Web网络，让信息分享越来越简单。 元宇宙“或称为後設宇宙、形上宇宙、元界、超感空间、虚空间，被用来描述一个未来和去中心化的在线虚拟环境。” 以上是维基百科的简单定义，直观体会跟万物互联，全真互联精髓是一致的，但补充定义上更强调了进一步的交互方案，更像是类似《头号玩家》中描述的交互体验。 始至终互联网的发展自始至终的目标都很清晰：提升信息沟通效率，降低成本。如同人与人之间的对话，最低效的沟通莫过于驴唇不对马嘴，生物作为“意识+肢体”结合产生的个体，意识与意识之间需要透过肢体协作才能交流，又或者需要透过外部复杂环境才能交流(地理位置、语种、视听语言障碍等等)，这都是交流的成本。 互联网的出现之所以普及，在于它能让人足不出户，就可以和任何人交流(电话、短信、微信、QQ)，足不出户就可以和全世界的人一起互动娱乐，学习，乃至生活的方方面面，甚至会有人沉迷于互联网络的虚拟世界中。 对于商业公司而言，需要新鲜的故事才能满足公司运作的需要，才能更好的发展。但对于科技的发展，元宇宙的当前定义或许还不到最终目标的10%，如果互联网能以最高效的方式连接「意识」，最大程度上降低现实世界中的沟通成本，也许就是达到了发展的终极目标，小时候看《黑客帝国》时，就在想，这插一下网线，想做什么就能做什么，想学什么瞬间就会，多爽啊，脑机交互始终是未来的一个很大的研究课题。 想象一下：人们通过佩戴一个头盔，或者内嵌脑机交互芯片，又或者后脑勺有一个网口，随时随地，连睡觉时依然能保持正常的日常生活(当然是在一个开放的虚拟世界中)，我在地球，你在火星，透过虚拟世界，实现面对面沟通。 新的变化Q：元宇宙与WEB3.0？ A：元宇宙与WEB3.0是同级别产品，但元宇宙的应用包含的维度更广。 Q：互联网与元宇宙？ A：元宇宙的建设包含先前技术的方方面面，元宇宙需要基于现有互联网络进行建设。 Q：元宇宙只有一个吗？ A：元宇宙最可能的结构是存在多个，主宇宙与私有宇宙。 Q：元宇宙能带来哪些商业变革？ A：元宇宙会建设成类似平台的模式，用户进入元宇宙的成本不能太高，因此交互设备的价格需要能让大众接受或者付费进入(共享设备或按时计费)。在元宇宙中，会存在虚拟商家，用户与虚拟商家的交互会在现实中得到体现。既然存在多个元宇宙，那用户怎么选择呢，是不是还需要一个导航？ 版本迭代v1.0：肢体沟通，面对面沟通原始阶段，需要面对面沟通，并且语种能互相识别，或者尽量少的语言视听障碍。 v2.0：通信方案、设备，传输介质存在中间传输层，如：书信，传信人，留言记录，电话，手机，im软件。 v3.0：VR，视频，语音，仿生技术，增强现实技术主要目标是进一步解放手动操作，降低操作性，反馈体验更加真实，并进一步提升通信效率。 一. 操作技术 NLP(支持实时同声交互) AI(交互容错) 肢体动作识别(辅助操作) 二. 反馈技术 VR 特效模拟 场景模拟 感官模拟 三. 辅助技术 3D建模 v4.0：脑机交互，虚拟世界与现实世界互联发展到这个阶段，只需要通过意识，便能完成交互。 其中最关键的两项技术：一项是脑机交互技术，另一项是高效率的无线通信技术。 一. 脑机交互技术解读所有大脑信号，实现意识与世界(虚拟世界或现实世界)的交互，并将结果反馈给大脑。 二. 超长距离高效率的无线通信技术有线通信技术，在不断扩大规模的情况下，成本也会不断增加，同时也会遇到很多现实世界的局限，未来星际发展，难道要直连一条从地球到火星的网线吗？ v5.0：《铳梦》，《超验骇客》当意识的构成被彻底研究透彻，科技可以对意识加以干扰和修改，配合优于人类意识的AI系统，作为人而存在的个体是否还需要肉体？所有的意识组件都被电子系统替代，如忒修斯之船一样，我们还是我们，但我们却也不是原来的我们。 到这里，我们不经提出几个问题： 人类还需要生殖繁衍吗？ 人类意识与AI意识怎么共存？ 在虚拟世界中，每一个具备意识的个体，这份意识可能出自人类，也可能是被系统创造出来的？ 在虚拟世界中，由系统创造出来的AI意识是不是原住民？ 很多不错的科幻电影都描述了这些很可能会到来的未来，身体是束缚意识的枷锁，电影《超验骇客》中，威尔的意识第一次进入电脑，进入网络中时，感叹，思维从未如此轻松。","categories":[{"name":"长话","slug":"长话","permalink":"https://oldchan.net/categories/长话/"}],"tags":[{"name":"元宇宙","slug":"元宇宙","permalink":"https://oldchan.net/tags/元宇宙/"}],"keywords":[{"name":"长话","slug":"长话","permalink":"https://oldchan.net/categories/长话/"}]},{"title":"微服务","slug":"arch/microservice/service","date":"2021-05-18T10:22:44.000Z","updated":"2022-06-02T12:47:44.815Z","comments":true,"path":"2021/05/18/arch/microservice/service/","link":"","permalink":"https://oldchan.net/2021/05/18/arch/microservice/service/","excerpt":"产业分工是产品成长过程中的必经阶段，但凡产品具有不断壮大的机会，规模也会不断扩大，相应的工艺也会逐渐复杂，这种情况下，模块化生产就是必要的生产方式。 之前在创业群里，有连续创业并成功的大佬就说过：“我们平时买的包子，里面就包含很多道工序，有人负责种麦子，有人负责养猪，有人负责加工面粉，有人负责杀猪，最后早餐店里员工进行产品包装。” 应用到软件架构，这些内在本质是相通的。随着用户量的不断增长，架构应对的数据规模也会逐渐发生质变，为什么几十年前不会诞生微服务这类概念，因为在那个时候互联网还远远不够目前的规模庞大。","text":"产业分工是产品成长过程中的必经阶段，但凡产品具有不断壮大的机会，规模也会不断扩大，相应的工艺也会逐渐复杂，这种情况下，模块化生产就是必要的生产方式。 之前在创业群里，有连续创业并成功的大佬就说过：“我们平时买的包子，里面就包含很多道工序，有人负责种麦子，有人负责养猪，有人负责加工面粉，有人负责杀猪，最后早餐店里员工进行产品包装。” 应用到软件架构，这些内在本质是相通的。随着用户量的不断增长，架构应对的数据规模也会逐渐发生质变，为什么几十年前不会诞生微服务这类概念，因为在那个时候互联网还远远不够目前的规模庞大。 SOASOA(Service-Oriented Architecture)是一种支持面向服务的架构风格，定义了将业务功能服务化的架构思想，但从各种材料中，都只看到“粗粒度，松耦合”的描述和一直被诟病的ESB组件。 SOA提出了服务化分工协作的思想，将完整的集中式架构进行了拆分，但在具体实现过程中，又保留了对现有系统的复用要求，因此才有ESB的存在，相比后来出现的微服务架构，SOA在整体架构上，有着服务化的理念却不够彻底。 微服务相比于SOA，很多有一定经验的架构师在最初接触微服务时，都会觉得两者在整体上何其相似。 在一篇技术文章里，有这么一段总结： “SOA的服务拆分建立在已有系统的基础上，不打破原有系统的整体架构，在接口集成时做的接口服务粒度的拆分，SOA架构通过对已有业务或系统的梳理来发现可提供复用的系统组件或功能，并统一通过Webservice来暴露接口。而目前流行的微服务架构的微服务组件的拆分则是将现有系统和业务重构，按照微服务的设计思路，将业务或系统打散成单个微服务组件，并基于微服务组件进行集成和组装编排，来生成全新的单体应用。” 由此看来，SOA架构实际上是集中式架构向服务化架构演化的过渡阶段，这种架构在短期阶段更适合已具备一定规模的企业，能快速继承现有业务系统，实现快速上线。 微服务架构包含的基本设施一般可以规划为以下几个分类： 链路治理从集中式架构演化成服务化架构，必然会带来链路问题，由于微服务架构的各个服务都具备单独治理/部署的能力，导致原本集中式架构中能够确保的通信质量，在微服务架构中就难以得到相同指标的保障，因此微服务基础设施中，链路层的组件相对其他分类要多一些。 服务发现、路由、跟踪、监控、容错，这几类关键技术会一直围绕着链路层不断展开。 通信协议与SOA架构不同的设计在于，微服务对通信和链路的要求更加轻量，服务与服务之间通过统一的协议进行数据交换，一般会采用RPC方式进行通信，早期不少企业也会直接采用HTTP协议进行通信。 统一网关所有的服务相互协作，共同组织成一个完整的产品架构，由统一的网关负责对外提供产品服务，负责鉴权等等。 工程自动化由于产品规模的扩大，服务的拆分，人工测试与部署存在明显的效率低下问题。","categories":[{"name":"架构","slug":"架构","permalink":"https://oldchan.net/categories/架构/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://oldchan.net/tags/微服务/"}],"keywords":[{"name":"架构","slug":"架构","permalink":"https://oldchan.net/categories/架构/"}]},{"title":"配置服务迁移","slug":"arch/middleware/configuration","date":"2021-04-06T10:22:44.000Z","updated":"2022-07-08T12:58:19.475Z","comments":true,"path":"2021/04/06/arch/middleware/configuration/","link":"","permalink":"https://oldchan.net/2021/04/06/arch/middleware/configuration/","excerpt":"关于迁移配置服务，早在2019年就有过计划，不过当时正忙于重构系统，所以也只在新系统里用过qcm，而在那时，考虑公司内部有太多的老项目，下线qconf时间自然就延期了。 去年云平台邮件通知，配置服务需要迁移，老版本的qconf需要下线，机房也要清退了，只能将现有手里项目都改用qcm。","text":"关于迁移配置服务，早在2019年就有过计划，不过当时正忙于重构系统，所以也只在新系统里用过qcm，而在那时，考虑公司内部有太多的老项目，下线qconf时间自然就延期了。 去年云平台邮件通知，配置服务需要迁移，老版本的qconf需要下线，机房也要清退了，只能将现有手里项目都改用qcm。 QConf与QCMQConf“QConf是一个集中式配置管理工具，能实现配置信息对业务的完全透明化。” 特点 基于zookeeper 需要安装agent进程 QCM“是一款在分布式架构环境中对应用配置进行集中管理和及时推送的服务。” 特点 基于etcd 在易用性方面相较qconf多了更多的改进 废弃qconf结构中使用的agent进程，改用扩展模块嵌入服务模式 前期调研的部分问题qcm扩展存在偶现不稳定问题 qcm的多种SDK版本都是从同一份lib源代码编译而成，经过SWIG生成各种语言可用的SDK扩展文件，最早在go项目中使用时，也是采用cgo的模式进行引用，但在实际运营过程中，就发现一些小问题，比如断网后，偶现的重连失败，后来也有其他团队同学反馈，进程在引入qcm扩展后，运行时间久了，会有一定概率crash。 项目中存在大量需要修改的逻辑代码 现有的很多服务，在接入qconf时，存在规范问题，比如有些逻辑中会直接引用qconf的原生接口，而又有些逻辑中，会单独封装类进行处理。 使用qconf时就计划要优化的问题 目前配置服务中，主要存储的都是服务运行期间的各种策略开关、接口校验token、ak/sk之类的数据，在使用qconf存储配置时，虽然本地会有一个agent可以缓存数据，但主要是存储于文件中，在qcm是引入扩展，继承了本地文件缓存的方案，但配置迁移前后会有很大改动。 qcm.so文件有17M 容器化部署服务，会去优化镜像的大小，qcm的扩展比服务的基础大小还要大，也没有专门的go代码包。 系统改进原则 剥离对特定扩展或环境的依赖，尽量用简单的组件接口进行封装实现，最后是选择用qcm的restAPI进行数据读取 代码逻辑中，对基础组件进行抽象，定义接口，再做迁移时，只需要有合适的具体代码实现即可，而不必修改大量的项目代码 少量/访问频率较高数据，尽量使用进程缓存 代码逻辑以php版本举例，go版本类似，针对qcm实现了Qcm、QcmCluster的两个模块，一个负责读取qcm节点数据，一个汇总多个Qcm类的实例，主要用于调度和提升数据可用性，调度时，总是优先读取同机房数据，如果出现机房内部网络问题，会尝试读取其他机房数据(内部机房都是光纤直连，延迟在毫秒级)。 配置接口(php版) 123456789101112131415161718192021interface ConfigInterface&#123; /** * 获取配置 * * @param string $key * @return string */ public function get($key); /** * 设置配置 * * @param string $key * @param string $value * @return bool */ public function set($key, $value);&#125; 结构方案 r表示读取，w表示写入 go项目选用开源工具统一管理内存(避免随处定义变量)，用来缓存数据decode之后的结果变量，并且周期性更新，缓存数据不设定过期时间，但上游数据读取失败，会记录错误并告警，读取成功则更新本地缓存 php中采用apc进行缓存，也是缓存decode之后的数据，同样是避免每一次都需要对原数据进行decode而带来的额外开销，不同的是php环境下，没有使用更新任务，而是在缓存上设置了过期时间，在处理请求时，处罚缓存失效事件，并同时更新apc。php缓存下，没有使用shm特性，数据量不大，内存完全吃的开，也避免多进程处理shm时使用到锁 redis缓存配置数据，主要是防止qcm故障问题，起到一定的容灾作用 数据监控工作中，遇到过数据不更新或者更新不及时问题，在使用qconf时，就遇到过agent进程异常退出，本地数据不更新问题，而定位问题总是打印出配置数据，人为检查数据是不是最新。 另一个目的，是希望对数据能做好实时的监控，所以在新的配置数据中，定义了一个数据结构 12345&#123; \"ver\": \"1617160952\", \"format\": \"json\", \"value\": \"原始配置\"&#125; 写入配置时记录版本号，数据在服务中被读取时，可以根据对比版本号，选择是否decode并更新配置数据，也避免重复的配置解析，而目前服务中用到的metrics监控，也专门针对配置设置了指标项，可以在grafana中，实时快捷查看，各节点数据的生效情况，起到数据遥测的作用。 在对配置数据增加额外结构时，除了增加版本字段和原始数据结构类型字段外，还有压缩和加密的方法字段，主要是考虑传输问题和共有服务中的数据安全问题。","categories":[{"name":"架构","slug":"架构","permalink":"https://oldchan.net/categories/架构/"}],"tags":[{"name":"中间件","slug":"中间件","permalink":"https://oldchan.net/tags/中间件/"}],"keywords":[{"name":"架构","slug":"架构","permalink":"https://oldchan.net/categories/架构/"}]},{"title":"最小化docker镜像(补充内容)","slug":"container/docker/minimum_ext","date":"2021-03-30T12:58:58.000Z","updated":"2022-06-02T12:47:44.816Z","comments":true,"path":"2021/03/30/container/docker/minimum_ext/","link":"","permalink":"https://oldchan.net/2021/03/30/container/docker/minimum_ext/","excerpt":"基于之前写的一篇《最小化docker镜像》做一些补充，对用到的工具，做一些解释和对比。","text":"基于之前写的一篇《最小化docker镜像》做一些补充，对用到的工具，做一些解释和对比。 Go程序构建时的-ldflags编译选项构建程序时，引入选项-ldflags=&quot;-w -s&quot;，平均单个文件大小减小20%左右 Command: go tool link ↓1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677usage: link [options] main.o -B note add an ELF NT_GNU_BUILD_ID note when using ELF -E entry set entry symbol name -H type set header type -I linker use linker as ELF dynamic linker -L directory add specified directory to library path -R quantum set address rounding quantum (default -1) -T address set text segment address (default -1) -V print version and exit -X definition add string value definition of the form importpath.name=value -a disassemble output -buildid id record id as Go toolchain build id -buildmode mode set build mode -c dump call graph -compressdwarf compress DWARF if possible (default true) -cpuprofile file write cpu profile to file -d disable dynamic executable -debugtramp int debug trampolines -dumpdep dump symbol dependency graph -extar string archive program for buildmode=c-archive -extld linker use linker when linking in external mode -extldflags flags pass flags to external linker -f ignore version mismatch -g disable go package data checks -h halt on error -importcfg file read import configuration from file -installsuffix suffix set package directory suffix -k symbol set field tracking symbol -libgcc string compiler support lib for internal linking; use \"none\" to disable -linkmode mode set link mode -linkshared link against installed Go shared libraries -memprofile file write memory profile to file -memprofilerate rate set runtime.MemProfileRate to rate -msan enable MSan interface -n dump symbol table -o file write output to file -pluginpath string full path name for plugin -r path set the ELF dynamic linker search path to dir1:dir2:... -race enable race detector -s disable symbol table // 删除符号表 -strictdups int sanity check duplicate symbol contents during object file reading (1=warn 2=err). -tmpdir directory use directory for temporary files -u reject unsafe packages -v print link trace -w disable DWARF generation // 删除DWARF调试信息 UPX压缩工具“UPX is a free, portable, extendable, high-performance executable packer for several executable formats.” 源代码: https://github.com/upx/upx Command: upx --help ↓123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118 Ultimate Packer for eXecutables Copyright (C) 1996 - 2020UPX 3.96 Markus Oberhumer, Laszlo Molnar &amp; John Reiser Jan 23rd 2020Usage: upx [-123456789dlthVL] [-qvfk] [-o file] file..Commands: -1 compress faster -9 compress better --best compress best (can be slow for big files) -d decompress -l list compressed file -t test compressed file -V display version number -h give this help -L display software licenseOptions: -q be quiet -v be verbose -oFILE write output to 'FILE' -f force compression of suspicious files --no-color, --mono, --color, --no-progress change lookCompression tuning options: --brute try all available compression methods &amp; filters [slow] --ultra-brute try even more compression variants [very slow]Backup options: -k, --backup keep backup files --no-backup no backup files [default]Overlay options: --overlay=copy copy any extra data attached to the file [default] --overlay=strip strip any extra data attached to the file [DANGEROUS] --overlay=skip don't compress a file with an overlayOptions for djgpp2/coff: --coff produce COFF output [default: EXE]Options for dos/com: --8086 make compressed com work on any 8086Options for dos/exe: --8086 make compressed exe work on any 8086 --no-reloc put no relocations in to the exe headerOptions for dos/sys: --8086 make compressed sys work on any 8086Options for ps1/exe: --8-bit uses 8 bit size compression [default: 32 bit] --8mib-ram 8 megabyte memory limit [default: 2 MiB] --boot-only disables client/host transfer compatibility --no-align don't align to 2048 bytes [enables: --console-run]Options for watcom/le: --le produce LE output [default: EXE]Options for win32/pe, win64/pe, rtm32/pe &amp; arm/pe: --compress-exports=0 do not compress the export section --compress-exports=1 compress the export section [default] --compress-icons=0 do not compress any icons --compress-icons=1 compress all but the first icon --compress-icons=2 compress all but the first icon directory [default] --compress-icons=3 compress all icons --compress-resources=0 do not compress any resources at all --keep-resource=list do not compress resources specified by list --strip-relocs=0 do not strip relocations --strip-relocs=1 strip relocations [default]Options for linux/elf: --preserve-build-id copy .gnu.note.build-id to compressed outputfile.. executables to (de)compressThis version supports: amd64-darwin.dylib dylib/amd64 amd64-darwin.macho macho/amd64 amd64-linux.elf linux/amd64 amd64-linux.kernel.vmlinux vmlinux/amd64 amd64-win64.pe win64/pe arm-darwin.macho macho/arm arm-linux.elf linux/arm arm-linux.kernel.vmlinux vmlinux/arm arm-linux.kernel.vmlinuz vmlinuz/arm arm-wince.pe arm/pe arm64-darwin.macho macho/arm64 arm64-linux.elf linux/arm64 armeb-linux.elf linux/armeb armeb-linux.kernel.vmlinux vmlinux/armeb fat-darwin.macho macho/fat i086-dos16.com dos/com i086-dos16.exe dos/exe i086-dos16.sys dos/sys i386-bsd.elf.execve bsd.exec/i386 i386-darwin.macho macho/i386 i386-dos32.djgpp2.coff djgpp2/coff i386-dos32.tmt.adam tmt/adam i386-dos32.watcom.le watcom/le i386-freebsd.elf freebsd/i386 i386-linux.elf linux/i386 i386-linux.elf.execve linux.exec/i386 i386-linux.elf.shell linux.sh/i386 i386-linux.kernel.bvmlinuz bvmlinuz/i386 i386-linux.kernel.vmlinux vmlinux/i386 i386-linux.kernel.vmlinuz vmlinuz/i386 i386-netbsd.elf netbsd/i386 i386-openbsd.elf openbsd/i386 i386-win32.pe win32/pe m68k-atari.tos atari/tos mips-linux.elf linux/mips mipsel-linux.elf linux/mipsel mipsel.r3000-ps1 ps1/exe powerpc-darwin.macho macho/ppc32 powerpc-linux.elf linux/ppc32 powerpc-linux.kernel.vmlinux vmlinux/ppc32 powerpc64-linux.elf linux/ppc64 powerpc64le-darwin.macho macho/ppc64le powerpc64le-linux.elf linux/ppc64le powerpc64le-linux.kernel.vmlinux vmlinux/ppc64leUPX comes with ABSOLUTELY NO WARRANTY; for details visit https://upx.github.io 特点 压缩可执行文件，压缩后的文件依然是可执行文件，并不影响程序的执行 老牌压缩软件，稳定，跨平台支持最好 团队维护，开发人员依然活跃 压缩比一般在20%-30%，如：10M压缩至3M Docker运行镜像alpine“Alpine Linux是一个面向安全的轻型的Linux发行版,基于Alpine Linux的超小型Docker镜像,大小只有5MB，并且可以访问比其他基于BusyBox的镜像更完整的包存储库。 Alpine Linux采用了 musl libc和busybox以减小系统的体积和运行时资源消耗，由于小巧、功能完备，非常适合用于作为容器的基础镜像。” 特点 轻量型linux发行版本，包含基于busybox的一些常用工具集 初始镜像大小在5M左右 scratch“an explicitly empty image, especially for building images FROM scratch“ 特点 docker的虚拟镜像，镜像大小接近于0 通过FROM scratch指令引用，没有真实镜像文件 关于选择Go服务依赖包“选择合适的，功能满足即可，不求大而全” 例: 采用一个功能齐全的配置解析包来解析yaml 服务 &lt; spf13/viper &lt; fsnotify &lt; golang.org/x/sys/unix 编译大小: 8M 服务 &lt; yaml.v2 编译大小: 5M","categories":[{"name":"容器","slug":"容器","permalink":"https://oldchan.net/categories/容器/"}],"tags":[{"name":"容器化","slug":"容器化","permalink":"https://oldchan.net/tags/容器化/"}],"keywords":[{"name":"容器","slug":"容器","permalink":"https://oldchan.net/categories/容器/"}]},{"title":"Go：实现类似class的析构函数","slug":"language/go/struct_like_class","date":"2021-02-20T08:58:58.000Z","updated":"2022-06-02T12:47:44.817Z","comments":true,"path":"2021/02/20/language/go/struct_like_class/","link":"","permalink":"https://oldchan.net/2021/02/20/language/go/struct_like_class/","excerpt":"Go提供的revicer满足函数简单的method操作结构，但并没有提供构造与析构的机制，在有些场景下，我们仍然需要一些能自动释放资源的逻辑。 在Go进程模型中，维护了一种叫finalizer的结构，当内存对象不可访问、需要被GC时，GC程序会检查对象关联的finalizer函数，如果有，则调用一次finalizer函数，并移除关联的finalizer函数，然后该对象再次变成可访问状态，当下一次，该对象再次被GC时，便会被释放并回收。 在runtime包中，对外暴露了一个函数SetFinalizer，用来设置关联的finalizer函数。","text":"Go提供的revicer满足函数简单的method操作结构，但并没有提供构造与析构的机制，在有些场景下，我们仍然需要一些能自动释放资源的逻辑。 在Go进程模型中，维护了一种叫finalizer的结构，当内存对象不可访问、需要被GC时，GC程序会检查对象关联的finalizer函数，如果有，则调用一次finalizer函数，并移除关联的finalizer函数，然后该对象再次变成可访问状态，当下一次，该对象再次被GC时，便会被释放并回收。 在runtime包中，对外暴露了一个函数SetFinalizer，用来设置关联的finalizer函数。 函数: runtime.SetFinalizer1func SetFinalizer(obj interface&#123;&#125;, finalizer interface&#123;&#125;) 构造与析构 定义Initializer接口，约定初始化函数 123type Initializer interface &#123; Init()&#125; 定义Finalizer接口，约定析构函数 123type Finalizer interface &#123; Delete()&#125; 定义InitObject函数用来初始化对象 12345678910111213// Sample: `InitObject(obj)`func InitObject(obj interface&#123;&#125;) &#123; // 如果obj实现了Initializer if ob, ok := obj.(Initializer); ok &#123; ob.Init() &#125; // 如果obj实现了Finalizer if ob, ok := obj.(Finalizer); ok &#123; runtime.SetFinalizer(ob, func(ob Finalizer) &#123; ob.Delete() &#125;) &#125;&#125; Sample12345678910111213141516171819202122232425262728type sample struct &#123;&#125;type Sample struct &#123; *sample&#125;// NewSample returns a Sample.func NewSample() *Sample &#123; // Private object s := &amp;sample&#123;&#125; // Public object obj := &amp;Sample&#123;s&#125; &#123; InitObject(obj) &#125; return obj&#125;// Init方法会在NewSample时，跟随InitObject执行。func (s *sample) Init() &#123; fmt.Printf(\"initialized\\n\")&#125;// Delete方法会在NewSample返回的obj需要被GC时调用。func (s *sample) Delete() &#123; fmt.Printf(\"deleted\\n\")&#125; 注意点 如果对象存在循环引用，可能永远都不会被GC finalizer设置的函数只会在GC时被调用 finalizer函数不适合处理太多耗时逻辑 finalizer函数延长了对象的生命周期，如果不必要，尽量不使用 我在一些项目中用到了自己封装的包，但只有少部分场景下用到了Delete()。 代码包：github.com/thecxx/jarvis","categories":[{"name":"编程","slug":"编程","permalink":"https://oldchan.net/categories/编程/"}],"tags":[{"name":"go","slug":"go","permalink":"https://oldchan.net/tags/go/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://oldchan.net/categories/编程/"}]},{"title":"最小化docker镜像","slug":"container/docker/minimum","date":"2020-04-20T08:58:58.000Z","updated":"2022-07-08T12:58:19.475Z","comments":true,"path":"2020/04/20/container/docker/minimum/","link":"","permalink":"https://oldchan.net/2020/04/20/container/docker/minimum/","excerpt":"容器化架构方案中，Worker节点启动容器需要获取对应版本的镜像，不管是从本地加载镜像或发布镜像，还是从镜像仓库拉取镜像，镜像越小，越易于传输。","text":"容器化架构方案中，Worker节点启动容器需要获取对应版本的镜像，不管是从本地加载镜像或发布镜像，还是从镜像仓库拉取镜像，镜像越小，越易于传输。 如何构建最小化容器镜像？服务程序足够小在编译服务程序时，大部分研发同学都会选择默认的方案进行编译，但对于go编程程序而言，还是有更多的优化空间的。 优化编译选项 如果能不使用cgo尽量不使用，如果一定要使用cgo的情况下尽量使用静态编译 go build是可以采用-ldflags=”-w -s”选项去掉调试信息与符号表 -w：去掉调试信息，得到的程序就不能用gdb调试 -s：去掉符号表，panic时候的stack trace就没有任何文件名/行号信息 使用压缩壳 网上看到很多优化镜像大小的文章，但是，从来没有看到有人提到用压缩壳的方案，也许是因为自己以前有写过压缩壳和脱壳的经历，最后选用了老牌的UPX进行压缩(主要是发现居然有linux版本的UPX)，压缩比一般在20~30%左右，但有一个问题，压缩后的程序，导入符号表被加密了，无法在压缩后ldd出依赖库，当有依赖库需要一起部署时，需要在压缩前提取 如果采用压缩壳，建议在编译阶段，尽量都采用静态编译，这样打包在程序内部的依赖库也能被压缩 经过压缩的程序，启动运行时会比未压缩程序稍慢，在程序大小20M-30M左右时，直观感觉能延迟0.2秒 镜像本身运行的基本环境足够小优化镜像，可以在构建镜像时，分成两阶段处理，第一个阶段：构建环境，第二个阶段：运行环境。 构建环境 主要用于构建程序使用，一般是提前构建好的成套环境，事先安装好了一系列构建环节必备的工具，如：gcc、go、glibc等等，保证程序编译正确，而且构建镜像可以作为通用构建镜像使用。 运行环境 主要在构建结束后，将必要的服务程序与依赖文件复制到运行镜像中，最终将运行镜像打包提交至仓库，而运行镜像可采用scratch空镜像作为基础镜像构建，确保系统环境最小化。 对比 — build build -ldflags=’-w’ upx -9 程序文件 33M 28M 8.8M 镜像大小 37M 32M 12M 镜像本身的大小在3~4M左右，当程序编译时，若采用’-s’编译选项，程序文件能进一步缩小化到25M左右，但再经过UPX压缩却效果不明显，最多只能进一步压到8M大小，而日常工作中，会需要保留一些日志数据，所以一般都只使用’-w’编译选项。","categories":[{"name":"容器","slug":"容器","permalink":"https://oldchan.net/categories/容器/"}],"tags":[{"name":"容器化","slug":"容器化","permalink":"https://oldchan.net/tags/容器化/"}],"keywords":[{"name":"容器","slug":"容器","permalink":"https://oldchan.net/categories/容器/"}]},{"title":"CPU的时间观念","slug":"os/cpu_and_time_management","date":"2020-03-11T08:26:21.000Z","updated":"2022-07-08T12:58:19.475Z","comments":true,"path":"2020/03/11/os/cpu_and_time_management/","link":"","permalink":"https://oldchan.net/2020/03/11/os/cpu_and_time_management/","excerpt":"","text":"“Next” “Next” “Next” “…” 对于CPU而言，存在的唯一意义就是永无休止地执行下一条指令和各种Jump，就像一个没有灵魂的时间管理大师一样，从每一次机器被启动开始便周而复始地践行着自己的使命：让系统里没有难做的任务。 CPU，系统与应用CPU：CPU的时间很紧张，以单核CPU为例，CPU自始至终只能执行一个任务，也并不会在意具体是谁的任务，可能是系统的任务，也有可能是某个应用的任务，只需要保证执行的指令都在物理内存上即可。 系统：系统组织软件与硬件资源，给应用提供一个稳定的环境来执行用户交代的任务。 应用：用户的任务逻辑经过编译器处理，由源代码翻译成机器码，并静态地保存在应用程序文件中，当系统执行应用程序时，会根据应用中的初始设置，将应用加载到内存中并执行。 进程与线程进程为满足多道编程，提高CPU的利用率，系统引入进程概念对任务资源进行管理。 系统每执行一次应用，就会创建一个进程，并将应用的静态机器码加载到进程的内存中，再从程序入口开始执行。 进程是应用执行过程中的真正实体，资源的容器。 线程线程是CPU的基本执行单位，同一个进程中可以包含一个或多个线程，多个线程共享进程的各种资源。除此之外，线程也具备一些独立维护的资源，如：调用栈，寄存器上下文，TLS等等。 将线程做为基本执行单元引入系统，能很大程度上降低进程级切换带来的性能开销，在很多操作系统中线程又被称之为轻量级进程，除了性能方面的改善之外，也为应用提供了并行执行任务的能力。 线程切换“A thread is a path of execution within a process. A process can contain multiple threads.” 这是一篇技术文章中对于线程概念的总结，进程中包含应用的所有任务指令，线程可以从进程中任意可执行的内存位置开始执行指令。 假如某应用中存在类似如下几个函数： 12345678910111213141516171819202122232425262728void *thread_fun_A(void *arg)&#123; int a = get_a(); printf(\"a + b = %d\\n\", a, 11, sum(a, 11)); return NULL;&#125;int sum(int a, int b)&#123; return a + b;&#125;void *thread_fun_B(void *arg)&#123; int a = get_a(); printf(\"a * b = %d\\n\", a, 11, mul(a, 11)) return NULL;&#125;int mul(int a, int b)&#123; return a * b;&#125;int get_a()&#123; return 10;&#125; 应用从main函数启动，分别创建了线程A从thread_fun_A开始执行和线程B从thread_fun_B开始执行，那两线程的执行路径分别是： 线程A：thread_fun_A()-&gt;get_a()-&gt;sum()-&gt;printf() 线程B：thread_fun_B()-&gt;get_a()-&gt;mul()-&gt;printf() 线程作为执行路径存在于系统的各进程和内核中，CPU作为执行人，需要频繁改变执行路径，时而在内核线程，时而在应用线程。 那么，多线程系统中，CPU是怎么切换线程的呢？ 系统调用系统一般会开放给应用程序很多有用的服务接口，应用基于这些接口可以实现很多有用的功能，比如最常见的读写文件，连接网络等等。 假如应用程序在执行某一个线程时，遇到需要写文件的操作，并且写的数据量较大，由于磁盘的性能弱于CPU，这时，在执行类似fwrite时，CPU就需要在内核调用中进入等待状态，等待磁盘操作完毕。很明显，这种情况下，CPU的使用率会明显下降，为了保证尽量少的出现这种情况，系统会挂起当前线程，并通过调度算法选择其他已就绪的线程供CPU继续执行，此时CPU的执行路径就发生了变化。 放弃调度跟系统调用类似，假如线程在执行过程中，并不需要调用系统执行具体功能，而是休眠一段时间或者等待某个信号产生再继续执行，会有类似sleep或wait***之类的系统接口调用，并进入挂起状态，此时CPU就会去执行其他就绪线程。 时钟中断有时，线程只需要执行某些算法代码，并不需要调用系统接口，假如算法复杂度较高，耗时较长，此时，CPU怎么保证执行线程时，不会被线程占用太多时间呢？因为其他线程的时间也是很宝贵的，CPU需要保证所有线程都能公平的被CPU执行。 为了防止CPU沉迷于某一个线程，系统在初始化的时候会初始化一个可编程的中断时钟，用来在线程执行超时时，向CPU产生一个中断，从而让CPU能够暂停线程的执行工作，回到内核，并调度其他线程。 CPU：“只要我够快，所有的线程都能得到满足😌” 进程：“我拥有应用执行过程中的所有资源，包括内存，句柄，线程执行路径等等” 线程：“我是进程的其中一条执行路径，CPU会按照我的指令执行”","categories":[{"name":"系统","slug":"系统","permalink":"https://oldchan.net/categories/系统/"}],"tags":[{"name":"cpu","slug":"cpu","permalink":"https://oldchan.net/tags/cpu/"}],"keywords":[{"name":"系统","slug":"系统","permalink":"https://oldchan.net/categories/系统/"}]},{"title":"Redis：hash","slug":"notes/redis/type_hash","date":"2018-09-23T13:04:02.000Z","updated":"2022-06-02T12:47:44.822Z","comments":true,"path":"2018/09/23/notes/redis/type_hash/","link":"","permalink":"https://oldchan.net/2018/09/23/notes/redis/type_hash/","excerpt":"hash数据结构在redis缓存中应用比较广泛，一般数据集合都会采用hash结构来进行存储，比如: session数据、在线用户记录等等。","text":"hash数据结构在redis缓存中应用比较广泛，一般数据集合都会采用hash结构来进行存储，比如: session数据、在线用户记录等等。 hash的创建使用hash时最常使用hset用来设置字段(“/src/t_hash.c”文件中)12345678910111213141516171819202122232425262728void hsetCommand(client *c) &#123; int i, created = 0; robj *o; if ((c-&gt;argc % 2) == 1) &#123; addReplyError(c,\"wrong number of arguments for HMSET\"); return; &#125; if ((o = hashTypeLookupWriteOrCreate(c,c-&gt;argv[1])) == NULL) return; hashTypeTryConversion(o,c-&gt;argv,2,c-&gt;argc-1); for (i = 2; i &lt; c-&gt;argc; i += 2) created += !hashTypeSet(o,c-&gt;argv[i]-&gt;ptr,c-&gt;argv[i+1]-&gt;ptr,HASH_SET_COPY); /* HMSET (deprecated) and HSET return value is different. */ char *cmdname = c-&gt;argv[0]-&gt;ptr; if (cmdname[1] == 's' || cmdname[1] == 'S') &#123; /* HSET */ addReplyLongLong(c, created); &#125; else &#123; /* HMSET */ addReply(c, shared.ok); &#125; signalModifiedKey(c-&gt;db,c-&gt;argv[1]); notifyKeyspaceEvent(NOTIFY_HASH,\"hset\",c-&gt;argv[1],c-&gt;db-&gt;id); server.dirty++;&#125; hset执行时，首先会检查k-v对的数量是否匹配 然后查询客户端对应的当前db，查找key对应结构(没有则创建一个ziplist的结构对象) 获取到结果，再通过hashTypeTryConversion函数尝试转换为dict结构(根据参数值大小决定) hsetCommand结构根据参数的数量，可以同时支持hset与hmset 常用命令参考: Hash","categories":[{"name":"笔记","slug":"笔记","permalink":"https://oldchan.net/categories/笔记/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://oldchan.net/tags/redis/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://oldchan.net/categories/笔记/"}]},{"title":"PE文件加载器","slug":"os/windows/pe_loader","date":"2018-09-10T13:39:49.000Z","updated":"2022-06-02T12:47:44.823Z","comments":true,"path":"2018/09/10/os/windows/pe_loader/","link":"","permalink":"https://oldchan.net/2018/09/10/os/windows/pe_loader/","excerpt":"分享一份自己之前总结以前的代码写的dll内存加载库C++版本项目要自行编译生成lib文件 支持： Win32标准Dll MFC Dll 易语言Dll 其他环境下生成的Dll但 不能加壳加密(原因跟加载方式有关，未添加至进程模块链表)","text":"分享一份自己之前总结以前的代码写的dll内存加载库C++版本项目要自行编译生成lib文件 支持： Win32标准Dll MFC Dll 易语言Dll 其他环境下生成的Dll但 不能加壳加密(原因跟加载方式有关，未添加至进程模块链表) 部分代码File: include/ldr.h1234567891011121314151617181920212223242526272829/* __ldr_header__ */#ifndef __LDR_H__#define __LDR_H__#ifdef _DEBUG#pragma comment(lib, \"image.d.lib\")#else#pragma comment(lib, \"image.lib\")#endif#ifdef _WIN32#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;tchar.h&gt;#include &lt;Windows.h&gt;#include &lt;WinNT.h&gt;#else#error Current platform is not supported#endiftypedef PVOID (__stdcall *malloc_t) (ULONG);typedef VOID (__stdcall *free_t) (PVOID);PVOID LdrLoadImage (PVOID Buffer, DWORD Size, malloc_t m = NULL, free_t f = NULL);PVOID LdrGetProcAddress (PVOID Addr, LPCSTR Name);VOID LdrFreeImage (PVOID Addr);#endif File: image/traps/GetModuleHandleW.asm 加入汇编代码主要是为了做中间层hook处理，否则非正常加载的模块部分接口不可用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.386.Model flat, StdCallOption CaseMap: none Include trap.inc .Const .Data? .Data .Code GetModuleHandleWTrap Proc Uses Ebx Ecx Edx Esi Edi, lpModuleName: Ptr WCHAR ; Mov Esi, 0x******** Mov_Esi_Information ; Pointer to ImageInformation Assume Esi: Ptr ImageInformation .If lpModuleName == 0 Push 0 Call [Esi].traps[SizeOf ImageTrap * TRAP_ID_GET_MODULE_HANDLE_W].procedure .Else Lea Ebx, [Esi].ModuleNameW Push Ebx Push lpModuleName Call [Esi].apis.lstrcmpiW Cmp Eax, 0 Je __COPY Lea Ebx, [Esi].ModuleBaseNameW Push Ebx Push lpModuleName Call [Esi].apis.lstrcmpiW Cmp Eax, 0 Jne __CALL __COPY: Mov Eax, [Esi].imagebase Jmp @F __CALL: Push lpModuleName Call [Esi].traps[SizeOf ImageTrap * TRAP_ID_GET_MODULE_HANDLE_W].procedure @@: .EndIf Return EaxGetModuleHandleWTrap EndP End 使用接口(对应关系) LdrLoadImage = LoadLibrary LdrGetProcAddress = GetProcAddress LdrFreeImage = FreeLibrary 项目地址https://github.com/thecxx/image","categories":[{"name":"系统","slug":"系统","permalink":"https://oldchan.net/categories/系统/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://oldchan.net/tags/windows/"}],"keywords":[{"name":"系统","slug":"系统","permalink":"https://oldchan.net/categories/系统/"}]},{"title":"Redis：常用数据结构","slug":"notes/redis/types","date":"2018-09-10T12:56:40.000Z","updated":"2022-06-02T12:47:44.822Z","comments":true,"path":"2018/09/10/notes/redis/types/","link":"","permalink":"https://oldchan.net/2018/09/10/notes/redis/types/","excerpt":"redis不仅支持最简单的k-v数据，还提供其他多种场景可用的数据结构: hash/list/set/zset等等。 hash list set zset","text":"redis不仅支持最简单的k-v数据，还提供其他多种场景可用的数据结构: hash/list/set/zset等等。 hash list set zset redis数据存储redis维护的db数据结构12345678910typedef struct redisDb &#123; dict *dict; /* The keyspace for this DB */ dict *expires; /* Timeout of keys with a timeout set */ dict *blocking_keys; /* Keys with clients waiting for data (BLPOP)*/ dict *ready_keys; /* Blocked keys that received a PUSH */ dict *watched_keys; /* WATCHED keys for MULTI/EXEC CAS */ int id; /* Database ID */ long long avg_ttl; /* Average TTL, just for stats */ list *defrag_later; /* List of key names to attempt to defrag one by one, gradually. */&#125; redisDb; dict: 保存的是当前db中所有key的一个dict结构 从一个指定db的dict结构中查找到对应redisObject结构的对象123456789typedef struct redisObject &#123; unsigned type:4; unsigned encoding:4; unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or * LFU data (least significant 8 bits frequency * and most significant 16 bits access time). */ int refcount; void *ptr;&#125; robj; 通过给定的命令，检查数据是否可操作 redis默认db数量为16","categories":[{"name":"笔记","slug":"笔记","permalink":"https://oldchan.net/categories/笔记/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://oldchan.net/tags/redis/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://oldchan.net/categories/笔记/"}]},{"title":"Go：语言监听进程退出信号","slug":"language/go/when_process_exit","date":"2018-09-10T11:14:30.000Z","updated":"2022-06-02T12:47:44.818Z","comments":true,"path":"2018/09/10/language/go/when_process_exit/","link":"","permalink":"https://oldchan.net/2018/09/10/language/go/when_process_exit/","excerpt":"项目中经常需要在进程退出时处理一些资源回收操作，打开的资源需要关闭，创建的临时数据需要销毁等等…","text":"项目中经常需要在进程退出时处理一些资源回收操作，打开的资源需要关闭，创建的临时数据需要销毁等等… 实现过程通过os/signal包来获取进程信号接收管道，用一个goroutine来等待指定的信号 1234567891011121314151617181920212223242526272829303132333435package utilsimport ( \"os\" \"os/signal\" \"syscall\")var ( exitHandlers []func(os.Signal))// 捕获进程退出信号，执行回调func WhenExit(handler func(os.Signal)) &#123; if len(exitHandlers) == 0 &#123; ch := make(chan os.Signal) sigs := []os.Signal&#123; syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT, syscall.SIGUSR1, syscall.SIGUSR2, &#125; signal.Notify(ch, sigs...) go func() &#123; s := &lt;-ch for _, handler := range exitHandlers &#123; handler(s) &#125; &#125;() &#125; // 增加退出回调 exitHandlers = append(exitHandlers, handler)&#125; 使用方法123WhenExit(func(sig os.Signal) &#123; // @todo something&#125;)","categories":[{"name":"编程","slug":"编程","permalink":"https://oldchan.net/categories/编程/"}],"tags":[{"name":"go","slug":"go","permalink":"https://oldchan.net/tags/go/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://oldchan.net/categories/编程/"}]},{"title":"Redis：浅析redis启动流程","slug":"notes/redis/startup","date":"2018-08-24T02:42:16.000Z","updated":"2022-06-02T12:47:44.822Z","comments":true,"path":"2018/08/24/notes/redis/startup/","link":"","permalink":"https://oldchan.net/2018/08/24/notes/redis/startup/","excerpt":"阅读了下redis的源代码，了解一下服务的启动流程。","text":"阅读了下redis的源代码，了解一下服务的启动流程。 程序入口mainmain函数做为c语言程序入口，redis中的main函数在文件”/src/server.c”中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240int main(int argc, char **argv) &#123; struct timeval tv; int j;#ifdef REDIS_TEST if (argc == 3 &amp;&amp; !strcasecmp(argv[1], \"test\")) &#123; if (!strcasecmp(argv[2], \"ziplist\")) &#123; return ziplistTest(argc, argv); &#125; else if (!strcasecmp(argv[2], \"quicklist\")) &#123; quicklistTest(argc, argv); &#125; else if (!strcasecmp(argv[2], \"intset\")) &#123; return intsetTest(argc, argv); &#125; else if (!strcasecmp(argv[2], \"zipmap\")) &#123; return zipmapTest(argc, argv); &#125; else if (!strcasecmp(argv[2], \"sha1test\")) &#123; return sha1Test(argc, argv); &#125; else if (!strcasecmp(argv[2], \"util\")) &#123; return utilTest(argc, argv); &#125; else if (!strcasecmp(argv[2], \"sds\")) &#123; return sdsTest(argc, argv); &#125; else if (!strcasecmp(argv[2], \"endianconv\")) &#123; return endianconvTest(argc, argv); &#125; else if (!strcasecmp(argv[2], \"crc64\")) &#123; return crc64Test(argc, argv); &#125; return -1; /* test not found */ &#125;#endif /* We need to initialize our libraries, and the server configuration. */#ifdef INIT_SETPROCTITLE_REPLACEMENT spt_init(argc, argv);#endif // 设置本地化 setlocale(LC_COLLATE,\"\"); // 设置时区 tzset(); /* Populates 'timezone' global. */ // OOM保护机制的处理接口 zmalloc_set_oom_handler(redisOutOfMemoryHandler); // 生成随机种子 srand(time(NULL)^getpid()); // 获取时间 gettimeofday(&amp;tv,NULL); // 生成一个随机16位长度字符串，用于后续使用生成hash(siphash)值时 char hashseed[16]; getRandomHexChars(hashseed,sizeof(hashseed)); dictSetHashFunctionSeed((uint8_t*)hashseed); // 检测是否启用sentinel server.sentinel_mode = checkForSentinelMode(argc,argv); // 初始化服务器配置 initServerConfig(); // 初始化模块系统 moduleInitModulesSystem(); /* Store the executable path and arguments in a safe place in order * to be able to restart the server later. */ server.executable = getAbsolutePath(argv[0]); server.exec_argv = zmalloc(sizeof(char*)*(argc+1)); server.exec_argv[argc] = NULL; for (j = 0; j &lt; argc; j++) server.exec_argv[j] = zstrdup(argv[j]); // 如果需要启动sentinel，则进行sentinel的初始化工作 /* We need to init sentinel right now as parsing the configuration file * in sentinel mode will have the effect of populating the sentinel * data structures with master nodes to monitor. */ if (server.sentinel_mode) &#123; initSentinelConfig(); initSentinel(); &#125; // 如只需检测rdb/aof是否正常可用，则检测完退出启动流程 /* Check if we need to start in redis-check-rdb/aof mode. We just execute * the program main. However the program is part of the Redis executable * so that we can easily execute an RDB check on loading errors. */ if (strstr(argv[0],\"redis-check-rdb\") != NULL) redis_check_rdb_main(argc,argv,NULL); else if (strstr(argv[0],\"redis-check-aof\") != NULL) redis_check_aof_main(argc,argv); if (argc &gt;= 2) &#123; j = 1; /* First option to parse in argv[] */ sds options = sdsempty(); char *configfile = NULL; // 查看版本/help相关操作，会在执行之后退出启动流程 /* Handle special options --help and --version */ if (strcmp(argv[1], \"-v\") == 0 || strcmp(argv[1], \"--version\") == 0) version(); if (strcmp(argv[1], \"--help\") == 0 || strcmp(argv[1], \"-h\") == 0) usage(); if (strcmp(argv[1], \"--test-memory\") == 0) &#123; if (argc == 3) &#123; memtest(atoi(argv[2]),50); exit(0); &#125; else &#123; fprintf(stderr,\"Please specify the amount of memory to test in megabytes.\\n\"); fprintf(stderr,\"Example: ./redis-server --test-memory 4096\\n\\n\"); exit(1); &#125; &#125; // 命令行参数格式: --参数名(上面-v/-h等参数特殊处理除外) // 第一个参数必须是非\"--\"前缀格式才做为配置文件解析 /* First argument is the config file name? */ if (argv[j][0] != '-' || argv[j][1] != '-') &#123; configfile = argv[j]; server.configfile = getAbsolutePath(configfile); /* Replace the config file in server.exec_argv with * its absolute path. */ zfree(server.exec_argv[j]); server.exec_argv[j] = zstrdup(server.configfile); j++; &#125; /* All the other options are parsed and conceptually appended to the * configuration file. For instance --port 6380 will generate the * string \"port 6380\\n\" to be parsed after the actual file name * is parsed, if any. */ while(j != argc) &#123; if (argv[j][0] == '-' &amp;&amp; argv[j][1] == '-') &#123; /* Option name */ if (!strcmp(argv[j], \"--check-rdb\")) &#123; /* Argument has no options, need to skip for parsing. */ j++; continue; &#125; if (sdslen(options)) options = sdscat(options,\"\\n\"); options = sdscat(options,argv[j]+2); options = sdscat(options,\" \"); &#125; else &#123; /* Option argument */ options = sdscatrepr(options,argv[j],strlen(argv[j])); options = sdscat(options,\" \"); &#125; j++; &#125; if (server.sentinel_mode &amp;&amp; configfile &amp;&amp; *configfile == '-') &#123; serverLog(LL_WARNING, \"Sentinel config from STDIN not allowed.\"); serverLog(LL_WARNING, \"Sentinel needs config file on disk to save state. Exiting...\"); exit(1); &#125; resetServerSaveParams(); // 加载配置文件，同时会将命令行参数追加到配置中，解析配置时会进行覆盖 loadServerConfig(configfile,options); sdsfree(options); &#125; serverLog(LL_WARNING, \"oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\"); serverLog(LL_WARNING, \"Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started\", REDIS_VERSION, (sizeof(long) == 8) ? 64 : 32, redisGitSHA1(), strtol(redisGitDirty(),NULL,10) &gt; 0, (int)getpid()); if (argc == 1) &#123; serverLog(LL_WARNING, \"Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf\", argv[0], server.sentinel_mode ? \"sentinel\" : \"redis\"); &#125; else &#123; serverLog(LL_WARNING, \"Configuration loaded\"); &#125; // 检查是否启用后台进程，如果启用则当前进程将在创建子进程成功之后退出 server.supervised = redisIsSupervised(server.supervised_mode); int background = server.daemonize &amp;&amp; !server.supervised; if (background) daemonize(); // 初始化服务器各项结构 initServer(); if (background || server.pidfile) createPidFile(); redisSetProcTitle(argv[0]); redisAsciiArt(); checkTcpBacklogSettings(); if (!server.sentinel_mode) &#123; /* Things not needed when running in Sentinel mode. */ serverLog(LL_WARNING,\"Server initialized\"); #ifdef __linux__ linuxMemoryWarnings(); #endif // 通过模块队列加载模块 moduleLoadFromQueue(); // 通过aof/rdb加载数据 loadDataFromDisk(); if (server.cluster_enabled) &#123; if (verifyClusterConfigWithData() == C_ERR) &#123; serverLog(LL_WARNING, \"You can't have keys in a DB different than DB 0 when in \" \"Cluster mode. Exiting.\"); exit(1); &#125; &#125; if (server.ipfd_count &gt; 0) serverLog(LL_NOTICE,\"Ready to accept connections\"); if (server.sofd &gt; 0) serverLog(LL_NOTICE,\"The server is now ready to accept connections at %s\", server.unixsocket); &#125; else &#123; sentinelIsRunning(); &#125; /* Warning the user about suspicious maxmemory setting. */ if (server.maxmemory &gt; 0 &amp;&amp; server.maxmemory &lt; 1024*1024) &#123; serverLog(LL_WARNING,\"WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?\", server.maxmemory); &#125; // 进入主循环的一次回调 aeSetBeforeSleepProc(server.el,beforeSleep); // 监听到事件之后的一次回调 aeSetAfterSleepProc(server.el,afterSleep); // 开启事件循环 aeMain(server.el); aeDeleteEventLoop(server.el); return 0;&#125; 事件循环aeMain服务启动之后，初始化完毕，就开始执行事件循环系统(“/src/ae.c”文件中)123456789void aeMain(aeEventLoop *eventLoop) &#123; eventLoop-&gt;stop = 0; while (!eventLoop-&gt;stop) &#123; if (eventLoop-&gt;beforesleep != NULL) eventLoop-&gt;beforesleep(eventLoop); // 处理事件 aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP); &#125;&#125; 循环前的beforesleep关于beforesleep的代码也整理出来看看12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/* This function gets called every time Redis is entering the * main loop of the event driven library, that is, before to sleep * for ready file descriptors. */void beforeSleep(struct aeEventLoop *eventLoop) &#123; UNUSED(eventLoop); /* Call the Redis Cluster before sleep function. Note that this function * may change the state of Redis Cluster (from ok to fail or vice versa), * so it's a good idea to call it before serving the unblocked clients * later in this function. */ if (server.cluster_enabled) clusterBeforeSleep(); // Key过期处理 /* Run a fast expire cycle (the called function will return * ASAP if a fast cycle is not needed). */ if (server.active_expire_enabled &amp;&amp; server.masterhost == NULL) activeExpireCycle(ACTIVE_EXPIRE_CYCLE_FAST); // 跟slave库的联系/数据的同步等等 /* Send all the slaves an ACK request if at least one client blocked * during the previous event loop iteration. */ if (server.get_ack_from_slaves) &#123; robj *argv[3]; argv[0] = createStringObject(\"REPLCONF\",8); argv[1] = createStringObject(\"GETACK\",6); argv[2] = createStringObject(\"*\",1); /* Not used argument. */ replicationFeedSlaves(server.slaves, server.slaveseldb, argv, 3); decrRefCount(argv[0]); decrRefCount(argv[1]); decrRefCount(argv[2]); server.get_ack_from_slaves = 0; &#125; // 处理上一个循环中未响应完的处理 /* Unblock all the clients blocked for synchronous replication * in WAIT. */ if (listLength(server.clients_waiting_acks)) processClientsWaitingReplicas(); /* Check if there are clients unblocked by modules that implement * blocking commands. */ moduleHandleBlockedClients(); /* Try to process pending commands for clients that were just unblocked. */ if (listLength(server.unblocked_clients)) processUnblockedClients(); // aof的处理(不是执行一条命令就追加一条，是在一个循环完，开始一个新的循环之前落地到磁盘) /* Write the AOF buffer on disk */ flushAppendOnlyFile(0); /* Handle writes with pending output buffers. */ handleClientsWithPendingWrites(); /* Before we are going to sleep, let the threads access the dataset by * releasing the GIL. Redis main thread will not touch anything at this * time. */ if (moduleCount()) moduleReleaseGIL();&#125; 事件处理aeProcessEvents系统主要处理两种事件: 一种时间事件，一种网络事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/* Process every pending time event, then every pending file event * (that may be registered by time event callbacks just processed). * Without special flags the function sleeps until some file event * fires, or when the next time event occurs (if any). * * If flags is 0, the function does nothing and returns. * if flags has AE_ALL_EVENTS set, all the kind of events are processed. * if flags has AE_FILE_EVENTS set, file events are processed. * if flags has AE_TIME_EVENTS set, time events are processed. * if flags has AE_DONT_WAIT set the function returns ASAP until all * if flags has AE_CALL_AFTER_SLEEP set, the aftersleep callback is called. * the events that's possible to process without to wait are processed. * * The function returns the number of events processed. */int aeProcessEvents(aeEventLoop *eventLoop, int flags)&#123; int processed = 0, numevents; /* Nothing to do? return ASAP */ if (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) return 0; /* Note that we want call select() even if there are no * file events to process as long as we want to process time * events, in order to sleep until the next time event is ready * to fire. */ if (eventLoop-&gt;maxfd != -1 || ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123; int j; aeTimeEvent *shortest = NULL; struct timeval tv, *tvp; if (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT)) shortest = aeSearchNearestTimer(eventLoop); if (shortest) &#123; long now_sec, now_ms; aeGetTime(&amp;now_sec, &amp;now_ms); tvp = &amp;tv; /* How many milliseconds we need to wait for the next * time event to fire? */ long long ms = (shortest-&gt;when_sec - now_sec)*1000 + shortest-&gt;when_ms - now_ms; if (ms &gt; 0) &#123; tvp-&gt;tv_sec = ms/1000; tvp-&gt;tv_usec = (ms % 1000)*1000; &#125; else &#123; tvp-&gt;tv_sec = 0; tvp-&gt;tv_usec = 0; &#125; &#125; else &#123; /* If we have to check for events but need to return * ASAP because of AE_DONT_WAIT we need to set the timeout * to zero */ if (flags &amp; AE_DONT_WAIT) &#123; tv.tv_sec = tv.tv_usec = 0; tvp = &amp;tv; &#125; else &#123; /* Otherwise we can block */ tvp = NULL; /* wait forever */ &#125; &#125; // tvp是等待时间，是距离下一个最近的时间事件的时间距离 // redis的循环事件是不等待的 // aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP); /* Call the multiplexing API, will return only on timeout or when * some event fires. */ numevents = aeApiPoll(eventLoop, tvp); /* After sleep callback. */ if (eventLoop-&gt;aftersleep != NULL &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP) eventLoop-&gt;aftersleep(eventLoop); for (j = 0; j &lt; numevents; j++) &#123; aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd]; int mask = eventLoop-&gt;fired[j].mask; int fd = eventLoop-&gt;fired[j].fd; int fired = 0; /* Number of events fired for current fd. */ /* Normally we execute the readable event first, and the writable * event laster. This is useful as sometimes we may be able * to serve the reply of a query immediately after processing the * query. * * However if AE_BARRIER is set in the mask, our application is * asking us to do the reverse: never fire the writable event * after the readable. In such a case, we invert the calls. * This is useful when, for instance, we want to do things * in the beforeSleep() hook, like fsynching a file to disk, * before replying to a client. */ int invert = fe-&gt;mask &amp; AE_BARRIER; /* Note the \"fe-&gt;mask &amp; mask &amp; ...\" code: maybe an already * processed event removed an element that fired and we still * didn't processed, so we check if the event is still valid. * * Fire the readable event if the call sequence is not * inverted. */ if (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123; fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask); fired++; &#125; /* Fire the writable event. */ if (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123; if (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123; fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask); fired++; &#125; &#125; /* If we have to invert the call, fire the readable event now * after the writable one. */ if (invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123; if (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123; fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask); fired++; &#125; &#125; processed++; &#125; &#125; /* Check time events */ if (flags &amp; AE_TIME_EVENTS) // 处理时间事件 processed += processTimeEvents(eventLoop); return processed; /* return the number of processed file/time events */&#125; 简单总结 主程序中进行各项程序初始化/服务初始化/模块初始化等等 系统初始化结束启动事件循环系统 对于客户端的相关读写操作均才用单线程模式处理 对于部分低级别任务采用后台线程异步处理","categories":[{"name":"笔记","slug":"笔记","permalink":"https://oldchan.net/categories/笔记/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://oldchan.net/tags/redis/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://oldchan.net/categories/笔记/"}]},{"title":"静态博客实现动态交互","slug":"others/interaction","date":"2017-08-30T06:05:57.000Z","updated":"2022-07-08T13:19:58.603Z","comments":true,"path":"2017/08/30/others/interaction/","link":"","permalink":"https://oldchan.net/2017/08/30/others/interaction/","excerpt":"静态博客没有动态的脚本，都是html/js/css形式的文件组成，想要实现动态的交互，需要借助第三方的一些渠道来实现。在之前，我的博客都是使用多说(服务已经关闭)来做动态评论，但是今天发现多说原来已经关闭了，于是重新找了一个替代服务：搜狐畅言。","text":"静态博客没有动态的脚本，都是html/js/css形式的文件组成，想要实现动态的交互，需要借助第三方的一些渠道来实现。在之前，我的博客都是使用多说(服务已经关闭)来做动态评论，但是今天发现多说原来已经关闭了，于是重新找了一个替代服务：搜狐畅言。 申请畅言帐号首先，进去搜狐畅言注册帐号，按照提示，一步一步对自己的站点做好配置，主要的一点是，畅言的站点必须备案过，还要过审核还能正常使用，不然只能使用15天。 安装畅言代码对于外挂式评论功能模块，都会提供一份嵌入代码，畅言也在帐号的管理后台提供了一份嵌入代码，代码提供三中平台使用，PC、WAP、自适应，我选择使用自适应的那份代码。 12345678910111213141516171819202122232425262728293031323334353637&lt;!--PC和WAP自适应版--&gt;&lt;div id=\"SOHUCS\" &gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; (function()&#123; var appid = '畅言帐号提供的应用ID'; var conf = '畅言帐号提供的配置ID'; var width = window.innerWidth || document.documentElement.clientWidth; if (width &lt; 960) &#123; window.document.write('&lt;script id=\"changyan_mobile_js\" charset=\"utf-8\" type=\"text/javascript\" src=\"https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&amp;conf=' + conf + '\"&gt;&lt;\\/script&gt;'); &#125; else &#123; var loadJs=function(d, a) &#123; var c = document.getElementsByTagName(\"head\")[0] || document.head || document.documentElement; var b = document.createElement(\"script\"); b.setAttribute(\"type\",\"text/javascript\"); b.setAttribute(\"charset\",\"UTF-8\"); b.setAttribute(\"src\",d); if(typeof a === \"function\") &#123; if(window.attachEvent) &#123; b.onreadystatechange = function() &#123; var e = b.readyState; if(e === \"loaded\" || e === \"complete\") &#123; b.onreadystatechange = null; a() &#125; &#125; &#125; else &#123; b.onload =a &#125; &#125; c.appendChild(b) &#125;; loadJs(\"https://changyan.sohu.com/upload/changyan.js\", function() &#123; window.changyan.api.config(&#123;appid:appid,conf:conf&#125;) &#125;); &#125; &#125;)();&lt;/script&gt; 以上代码，嵌入到需要使用评论框的地方即可。 评论管理到这里，任何在博客里评论的内容都能通过畅言的后台进行管理了，另外畅言还提供一些其他的互动功能，包括任务、点赞之类的功能也比较丰富。其次，畅言还提供一个chrome扩展用来方便的直接在博客页面管理评论。","categories":[{"name":"长话","slug":"长话","permalink":"https://oldchan.net/categories/长话/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://oldchan.net/tags/博客/"}],"keywords":[{"name":"长话","slug":"长话","permalink":"https://oldchan.net/categories/长话/"}]},{"title":"ShellCode For LoadLibrary","slug":"os/windows/shellcode","date":"2016-05-12T02:28:28.000Z","updated":"2022-06-02T12:47:44.823Z","comments":true,"path":"2016/05/12/os/windows/shellcode/","link":"","permalink":"https://oldchan.net/2016/05/12/os/windows/shellcode/","excerpt":"方便快速注入插件，又增加可移植性，将必要的系统接口通过参数传递到函数内 使用时正确初始化参数，然后将函数的内存code与参数一起拷贝到指定进程中 LoadClientLibrary使用裸函数约定，结束标志方便定位函数总内存长度","text":"方便快速注入插件，又增加可移植性，将必要的系统接口通过参数传递到函数内 使用时正确初始化参数，然后将函数的内存code与参数一起拷贝到指定进程中 LoadClientLibrary使用裸函数约定，结束标志方便定位函数总内存长度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#pragma pack(push, 1)typedef struct &#123; DWORD SizeOfParameter: 32; CHAR Buffer[1024];&#125; CALLBACK_PROC_PARAMETER, *PCALLBACK_PROC_PARAMETER;typedef struct &#123; /* 系统接口 */ HMODULE (WINAPI *LoadLibrary)(__IN LPCSTR); FARPROC (WINAPI *GetProcAddress)(__IN HMODULE, __IN LPCSTR); /* 注入信息 */ CHAR InjectLibrary[MAX_PATH]; CHAR InjectProcedure[100]; CALLBACK_PROC_PARAMETER CommandLine;&#125; REMOTE_THREAD_PARAM, *PREMOTE_THREAD_PARAM;#pragma pack(pop)__NAKED BOOL WINAPI LoadClientLibrary(__IN PREMOTE_THREAD_PARAM lpThreadParameter)&#123; __asm &#123; // 函数开始 push ebp mov ebp, esp // 分配变量 sub esp, 0x08 // [ebp - 0x04]: ClientLibrary // [ebp - 0x08]: ClientProcedure &#125; __asm &#123; // 程序代码 xor eax, eax push ebx push ecx push edx push edi push esi mov esi, lpThreadParameter lea eax, [esi + 0x08] push eax call [esi] cmp eax, 0 je __EXIT_LABEL mov [ebp - 0x04], eax lea eax, [esi + 0x0000010C] push eax push [ebp - 0x04] call [esi + 0x04] cmp eax, 0 je __EXIT_LABEL mov [ebp - 0x08], eax lea eax, [esi + 0x00000170] push eax call [ebp - 0x08]__EXIT_LABEL: pop esi pop edi pop edx pop ecx pop ebx &#125; __asm &#123; // 销毁变量 add esp, 0x08 // 函数结束 mov esp, ebp pop ebp &#125; __asm &#123; // 返回并清除堆栈参数 ret 0x04 &#125; // 结束标志 __asm &#123; __emit 0x19 __emit 0x90 __emit 0x04 __emit 0x03 &#125;&#125;","categories":[{"name":"系统","slug":"系统","permalink":"https://oldchan.net/categories/系统/"}],"tags":[{"name":"注入","slug":"注入","permalink":"https://oldchan.net/tags/注入/"}],"keywords":[{"name":"系统","slug":"系统","permalink":"https://oldchan.net/categories/系统/"}]},{"title":"Windows系统服务描述表","slug":"os/windows/ke_service_descriptor_table","date":"2014-09-13T07:47:35.000Z","updated":"2022-06-02T12:47:44.823Z","comments":true,"path":"2014/09/13/os/windows/ke_service_descriptor_table/","link":"","permalink":"https://oldchan.net/2014/09/13/os/windows/ke_service_descriptor_table/","excerpt":"Win32下获取系统服务描述表的方法 123456789101112131415161718192021PSYSTEM_SERVICE_DESCRIPTOR_TABLE KeGetServiceDescriptorTable()&#123; // 结果值 PSYSTEM_SERVICE_DESCRIPTOR_TABLE ServiceDescriptorTable = NULL; __asm &#123; push eax push ebx push OffsetKthreadServiceTable call OffsetGet mov ebx, eax mov eax, dword ptr fs:[0x124] add eax, ebx mov eax, dword ptr [eax] mov ServiceDescriptorTable, eax pop ebx pop eax &#125; return ServiceDescriptorTable;&#125; OffsetGet这个自定义函数是为了兼容多系统版本，根据常量OffsetKthreadServiceTable的值来获取对应偏移 在驱动入口函数DriverEntry中获取的是SSDT，DeviceIoControl访问时，获取的是才是完整版KeServiceDescriptorTable","text":"Win32下获取系统服务描述表的方法 123456789101112131415161718192021PSYSTEM_SERVICE_DESCRIPTOR_TABLE KeGetServiceDescriptorTable()&#123; // 结果值 PSYSTEM_SERVICE_DESCRIPTOR_TABLE ServiceDescriptorTable = NULL; __asm &#123; push eax push ebx push OffsetKthreadServiceTable call OffsetGet mov ebx, eax mov eax, dword ptr fs:[0x124] add eax, ebx mov eax, dword ptr [eax] mov ServiceDescriptorTable, eax pop ebx pop eax &#125; return ServiceDescriptorTable;&#125; OffsetGet这个自定义函数是为了兼容多系统版本，根据常量OffsetKthreadServiceTable的值来获取对应偏移 在驱动入口函数DriverEntry中获取的是SSDT，DeviceIoControl访问时，获取的是才是完整版KeServiceDescriptorTable 12345678910111213141516171819202122232425262728293031323334353637383940/************************************************************************//* 获取系统服务描述表(SSDT Shadow) *//************************************************************************/PSERVICE_TABLE_DESCRIPTOR KeGetServiceDescriptorTableShadow()&#123; PUCHAR Pos; PUCHAR BeginPos = (PUCHAR)KeAddSystemServiceTable; static PSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTableShadow = NULL; // 返回现有值 if(KeServiceDescriptorTableShadow) &#123; return KeServiceDescriptorTableShadow; &#125; // Search for(Pos = BeginPos; Pos &lt; BeginPos + PAGE_SIZE; ++Pos) &#123; if(!MmIsAddressValid(Pos)) &#123; continue; &#125; KeServiceDescriptorTableShadow = (PSERVICE_TABLE_DESCRIPTOR)(*(PULONG)Pos); if (!MmIsAddressValid((PVOID)KeServiceDescriptorTableShadow)) &#123; continue; &#125; else if (memcmp((PVOID)KeServiceDescriptorTableShadow, &amp;KeServiceDescriptorTable[0], sizeof(SERVICE_TABLE_DESCRIPTOR)) == 0) &#123; if ((PVOID)KeServiceDescriptorTableShadow == (PVOID)&amp;KeServiceDescriptorTable[0]) &#123; continue; &#125; return KeServiceDescriptorTableShadow; &#125; &#125; return KeServiceDescriptorTableShadow = NULL;&#125; 2016年新加的获取方式，用的比较多","categories":[{"name":"系统","slug":"系统","permalink":"https://oldchan.net/categories/系统/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://oldchan.net/tags/windows/"}],"keywords":[{"name":"系统","slug":"系统","permalink":"https://oldchan.net/categories/系统/"}]}]}